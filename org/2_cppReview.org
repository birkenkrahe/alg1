#+TITLE:C++ Basics review
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:CSC 240 - Data structures with C++ - Lyon College, FA24
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:C++ :main yes :includes <iostream> :results output :exports both :noweb yes
* Overview

*Fast paced C++ review and overview including:*
1) Structure of C++ programs
2) "Hello world" sample program
3) =main= function, =#include= and =namespace=
4) Declaring and initializing variables
5) Conditional control statements
6) Functions
7) Printing format specifiers
8) Comments
9) Debugging with =gdb= and pythontutor.
10) Simple Exercises for class and home assignments

Just enough to be able to follow the rest of the course!

You should code along for a large part of this lecture!

* The Structure of a Basic C++ Program

- What is required to create and run a C++ program?
  #+begin_quote
  1. An editor to create the source code (like Emacs).
  2. A compiler to turn the source code into executable code (like GCC).
  3. A linker to link libraries (like =iostream=) to the source code file.
  4. A shell (or an IDE with a shell) to run the executable (like =bash=).
  #+end_quote

- What must every C++ program have?
  #+begin_quote
  A =main= function. Optional: Preprocessor directives (like =#include=).
  #+end_quote

* A first C++ program in six incarnations

For this section, fire up Emacs, open a file (~C-x C-f first.org RET)~
and code along. To create a C++ code block, enter ~<s TAB C++~, to run
it, ~C-c C-c~. What happens when you run a code block?[fn:2]

1) Example: "Hello world" program - can you explain every line?
   #+begin_src C++ :results output :exports both
     #include <cstdio>

     int main() {

       printf("Hello, world!");

       return 0;
     }
   #+end_src

   #+RESULTS:
   : Hello, world!

2) A good habit: Provide ample comments (especially at the beginning)
   #+begin_src C++ :results output :exports both
     /* --------------------------------------------*/
     /* Print a string to a standard output device  */
     /* --------------------------------------------*/
     // include standard input/output library
     #include <cstdio>
     // main program
     int main() {  // return integer, take no argument (void)
       // print string
       printf("Hello, world!");
       // return 0 if successful
       return 0;
     } // end of main program
   #+end_src

   #+RESULTS:
   : Hello, world!

3) Here is another version: What's different?
   #+begin_src C++ :results output :exports both
     /* --------------------------------------------*/
     /* Print a string to a standard output device  */
     /* Use character array and formatted printing  */
     /* --------------------------------------------*/
     #include <cstdio>
     // main program
     int main() {  // return integer, take no argument (void)
       // declare and initialize character array
       char greeting[] = {"Hello, world!"};
       // print string
       printf("%s\n", greeting);
       // return 0 if successful
       return 0;
     } // end of main program
   #+end_src

   #+RESULTS:
   : Hello, world!

4) And another version: What's different?
   #+begin_src C++ :results output :exports both
     /* --------------------------------------------*/
     /* Print a string to a standard output device  */
     /* Use iostream and stream extraction cout <<  */
     /* --------------------------------------------*/
     #include <iostream>
     // main program
     int main() {  // return integer, take no argument (void)
       // print string
       std::cout << "Hello, world!" << std::endl; // << "\n"; would also work
       // return 0 if successful
       return 0;
     } // end of main program
   #+end_src

   #+RESULTS:
   : Hello, world!

5) With the magic of Emacs + Org-mode, one could almost believe that
   C++ was Python or R - what's different?
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :tangle hw.cpp :results output :exports both
     // print string to standard output device
     cout << "Hello, world!" << endl;
   #+end_src

   #+RESULTS:
   : Hello, world!

6) Literate programming: The last code block can be "tangled" into
   source code:
   #+begin_src bash :results output :exports both
     cat hw.cpp
   #+end_src

7) The source code file can be compiled and run on the command line (or
   in a shell in this Org-mode file):
   #+begin_src bash :results output :exports both
     g++ -o hello hw.cpp
     ./hello
   #+end_src

   #+RESULTS:
   : Hello, world!

* =main=

- All C++ programs have a single entry point called the =main= function.

- Functions are blocks of code that can take input and return results:
  #+begin_src C++ :tangle hw2.cpp :main no :includes <iostream> :namespaces std :results output :exports both
    void hello() { // function declaration and definition
      cout << "hello" << endl;
    }
    main() { // program entry point
      hello();  // function call
    }
  #+end_src

  #+RESULTS:
  : hello

- Look at the tangled file:
  #+begin_src bash :results output :exports both
    cat hw2.cpp
  #+end_src

- When you define your own functions (or classes and their member
  functions), you need to declare them before =main= (you can define
  them later).

- In this code, ~hello~ is declared as a prototype, and defined later:
  #+begin_src C++ :tangle hw2.cpp :main no :includes <iostream> :namespaces std :results output :exports both
    void hello(); // function declaration (prototype)

    int main() { // program entry point
      hello();  // function call
      return 0;
    }

    void hello() { // function definition
      cout << "hello" << endl;
    }
  #+end_src

  #+RESULTS:
  : hello

* =#include=

- Most programming languages incorporate library functions. Libraries
  are often sizeable and must be installed, sometimes compiled from
  source, and they're linked to the language version used.

- Python, Go and Java have =import=. Here's a Python example:
  #+begin_src python :results output :session *Python* :python python3 :exports both
    import numpy # import library (install with `pip`)
    [print(_) for _ in globals()]
  #+end_src

  #+RESULTS:
  #+begin_example
  __name__
  __doc__
  __package__
  __loader__
  __spec__
  __annotations__
  __builtins__
  codecs
  os
  __pyfile
  __code
  __org_babel_python_format_value
  __PYTHON_EL_native_completion_setup
  f
  np
  x
  math
  numpy
  #+end_example

- R has =library=:
  #+begin_src R :session *R* :results output :exports both
    library(MASS) # import stats library (install with `install.packages`
    search()
  #+end_src

  #+RESULTS:
  : [1] ".GlobalEnv"        "package:MASS"      "ESSR"              "package:stats"
  :  [5] "package:graphics"  "package:grDevices" "package:utils"     "package:datasets"
  :  [9] "package:methods"   "Autoloads"         "package:base"

- Rust and C# have =use=, JavaScript, Lua, Perl and PHP have =require=,
  and C/C++ have =include=.

- In the C++ examples so far, we included =iostream= (for =cout= and =<<=),
  and =cstdio= (for =printf=).

- The command =#include= is only one of many possible /preprocessor/
  directives

* =namespace=

- Namespaces prevent naming conflicts. For example, when importing
  libraries, namespaces are essential for identifying symbols.

- The keyword =cout= to direct output to standard output devices (like a
  screen) is defined in the =std= namespace ('standard'). Its full name
  is therefore =std::cout=.

- You can employ a =using= (preprocessor) directive to avoid a lot of
  typing:
  #+begin_src C++ :main yes :includes <iostream> :results output :exports both
    using namespace std;
    cout << "Much shorter than..." << endl;
    std::cout << "...this statement." << std::endl;
  #+end_src

  #+RESULTS:
  : Much shorter than...
  : ...this statement.

- This is the same thing that's going on when using =import= in Python
  and choosing an alias: =np= allows you to access all members of the
  =numpy= library, e.g. the =array= function.
  #+begin_src python :results output :session *Python* :python python3 :exports both
    import numpy as np
    x = np.array([1,2,3,4,5]) # define
    print(x)
  #+end_src

  #+RESULTS:
  : [1 2 3 4 5]

- In Emacs Lisp (the language most of Emacs is written in),
  =org-version= is a member of two namespaces: it's the name of a
  variable, and a function of the same name:
  #+begin_src emacs-lisp :results value
    (message org-version) ;; extract variable - prints 9.7.7
    (org-version)  ;; run function - prints 9.7.7
  #+end_src

  #+RESULTS:
  : 9.7.7

- By default, all symbols you declare go into the global namespace.
  In C++, you can define your own namespace and place your symbols
  into it - this affords additional /encapsulation/, an important
  principle of object-oriented programming.

* The C++ Type System

- C++ is an object-oriented (OO) programming language. What does that
  mean?

- Everything in C++ has a state and a behavior, something it is
  (attribute, feature), and something it can do (method, function).

- Example: A car.
  1. The car's states are moving or standing.
  2. The car has a certain weight, a color, a brand.
  3. The car can move, accelerate, stop, honk.

- In addition, some of the properties of the car can be considered
  "private" or hidden (e.g. the fuel state - empty or full, or the
  mileage) while others are "public" or visible (e.g. the color and
  the brand).

- The Unified Modeling Language (UML) has a diagram ("class diagram")
  just for the description of objects and their relationships, like
  this[fn:1]:
  #+BEGIN_SRC dot :file car_class_diagram.png :exports results
    digraph G {
    node [shape=record];
    Car [
    label="{Car|
    - fuel: bool\n
    - mileage: float\n
    + color: string\n
    + brand: string|
    + honk(): void\n
    + move(): void\n
    + stop(): void
    }"
    ];
    }
  #+END_SRC

#+RESULTS:
[[file:car_class_diagram.png]]

- A data type is the collection of behaviors and states that describe
  an object. In our example, the =car= is a user-defined data type.

- C++ is a /strongly typed language/, which means that each object has a
  predefined data type.

- Example: =int= represents the built-in integer type.
  1. An =int= object can store whole numbers (state).
  2. An =int= object represents a certain amount of memory (state).
  3. An =int= object supports math operations (behavior).
  4. An =int= object is printed with the =%d= format specifier (state).

- To do anything with objects, you need to name them. Named objects
  become variables.

* Declaring and Initializing Variables

- You declare variables by providing their type, followed by their
  name, followed by a semicolon:
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
    int foo;  // declare integer variable named `foo`
  #+end_src

- When you declare a variable, you initialize it - set its initial
  state such as setting its value and/or reserving memory for later
  assignment of a value:
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
    // declare
    int foo;
    // define
    foo = 42;
    // declare and define
    int bar = 2;

    // declare and define after evaluating an expression
    int baz = foo * bar;

    // print all variables
    cout << foo << " * " << bar << " = " << baz << " " << endl;
  #+end_src

  #+RESULTS:
  : 42 * 2 = 84

- What happens if you divide two integers and the numerator is not a
  multiple of the denominator?
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
    int foo = 42, bar = 4;
    cout << foo/bar << endl; // 42 / 4 = 40/4 + 2/4 = 10 1/2 = 10.5
  #+end_src

  #+RESULTS:
  : 10

- Answer:
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
    // Widening conversion
    int foo = 42, bar = 4;
    cout << float(foo)/float(bar) << endl; // 42 / 4 = 40/4 + 2/4 = 10 1/2 = 10.5
  #+end_src

  #+RESULTS:
  : 10.5

- The other common built-in data types besides =int= are =float= and =bool=.

* Conditional Statements

- Conditional statements allow you to make decisions based on Boolean
  expressions, which evaluate to true or false.

- You can use comparison operators like ==== or =<== to build up Boolean
  expressions that represent logical choices: "When the sun shines,
  the weather is good," can be translated into this C++ code:
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
    // premise
    bool sun = false; // true = 1 or false = 0 also works
    // conclusion
    if (sun == true) {
      // good weather: sun is shining
      cout << "The weather is good" << endl;
     } else {
      // bad weather: sun is not shining
      cout << "The weather is bad" << endl;
     }
  #+end_src

  #+RESULTS:
  : The weather is good

- Can you change the program to represent the following statement:
  "When the sun shines and there's rain, we're getting rainbows."
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
    // premise
    bool sun = true, rain = true;
    // conclusion
    if (sun == true and rain == true) { // && would also work instead of `and`
      // good weather: sun is shining
      cout << "We're getting rainbows" << endl;
     } else {
      // bad weather: sun is not shining
      cout << "We're not getting rainbows" << endl;
     }
  #+end_src

  #+RESULTS:
  : We're getting rainbows

- If the first =if= condition is not true, the =else= statement is
  executed. You can also have any number of choices tested in
  cascading =else if= conditions (the =else= is optional):
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
    int x = 0;
    if (x > 0) printf("Positive.");  // branch one
     else if (x < 0) printf("Negative."); // branch two
     else printf("Zero."); // default branch
  #+end_src

  #+RESULTS:
  : Zero.

* Functions

      - Functions are code blocks that accept any number of input objects
        called /parameters/ or /arguments/, and that can =return= output objects
        when called.

      - They have a =return= type. If no such type is specified, they are =void=
        (better to specify that, too).

      - Example: A mathematical step Function. What is it? Is it
        important[fn:3]?
        #+begin_quote
        The step function is -1 for all arguments smaller than zero, 1 for all
        arguments greater than zero, and zero for a zero argument.
        #+end_quote

      - It's useful to plot functions in 2D if you can:
        #+begin_src python :file ../img/step.png :results file graphics output :session *Python2* :python python3 :exports both
          ## Plot a step function - mathematically:
          ## \forall x \in [-1,0): f(x) = -1, \forall x \in (0,1]: f(x) = 1
          ## -------------------------------------------------
          # import graphics library
          import matplotlib.pyplot as plt
          # x and f(x) = y
          x = [-1,0,0,1]
          y = [-1,-1,1,1]
          # plot f(x)
          plt.clf() # clear graphics
          #plt.plot(x,y,marker='o',linestyle="")  # shows the four points
          plt.plot(x,y,linewidth=2) # draws a line between them
          plt.axhline(0,color="black")
          plt.xlabel("x")
          plt.ylabel("f(x)")
          plt.title("Step Function")
          plt.savefig("../img/step.png")
        #+end_src

        #+RESULTS:
        [[file:../img/step.png]]

      - Before writing the code, let's understand what we're after:
        1) the function should take one integer argument
        2) the function should return one of: -1, 0, 1
        3) the return value depends on the argument
        #+begin_example
          // define function
          int step(int x) {
              // compute result for x < 0
              // compute result for x = 0
              // compute result for x > 0
              // return result
          }
        #+end_example

      - We call the function from =main=
        #+begin_src C++ :main no :includes <iostream> :namespaces std :results output :exports both
          // define step function
          int step(int x) {
            int y = 0; // initialize y
            if (x < 0) { // compute y for negative x
              y = -1;
            } else if (x > 0) { // compute y for positive x
              y = 1;
            }
            return y;
          }
          // main function
          int main() {
            // call function for negative integer
            cout << step(-10) << endl;
            // call function for zero 
            cout << step(0) << endl;
            // call function for positive integer
            cout << step(100) << endl;
            return 0;
          }
        #+end_src

        #+RESULTS:
        : -1
        : 0
        : 1

* Print format specifiers

- =cout= with =<<= is pretty comfortable but =printf= is a lot more
  flexible.

- The first argument of =printf= is always a /format string/, like =%m.pf=
  =float= values with =m= spacees and a precision of =p=

- Example: To print 3.1459 righ-aligned on 10 places:
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
    printf("%10.4f\n", 3.1459);
    printf("|----|----|");
  #+end_src

  #+RESULTS:
  :     3.1459
  : |----|----|

- 
  #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both

  #+end_src

- People have strong opinions when it comes to teaching C++ I/O:
  1) =cstdio::printf= goes back to C and has a lot more flexibility but
     is also more error prone.
  2) =iostream::cout= is part of the C++ standard library but involves a
     lot of complicated concepts (stream buffers, =<<= operator, =flush=
     into a /destructor/ method, =setf= etc.).

* Comments (and Pseudocode)

- Comments (like pseudocode) are non-standard and subjective.

- You can't overdo it with comments when learning a language

- Professional commenting is different (for code sharing)

- When you use literate programming techniques and apps (like Emacs +
  Org-mode, or Jupyter, or noweb), you don't need any comments at all.

- At the start, you should write pseudocode for every new algorithm,
  and your pseudocode should turn into comments

- The most important comment is the multi-line description of your
  program at the top.

- Example (Smith, 2023): write pseudocode for the following problem.
  #+begin_quote
  This program will request a student's score from the user. If the
  score is above 60 then a "passed" message will be delivered; if not,
  a "failed" message will be delivered.
  #+end_quote

- Sample solution:
  
  1) First attempt - what are the pros and cons?
     #+begin_example   
     // load I/O library
   
     // get user input
   
     // compute result

     // print result
     #+end_example

     #+begin_quote
     - Pros: task completely covered (start-end), syntax-free
     - Cons: lacks necessary detail, especially for algorithm
     #+end_quote

  2) Second attempt - what are the pros and cons?
     #+begin_example
     /* ------------------------------------------------------------ */
     /* Get score from user and return "passed" or "failed" message. */
     /* Sample input: 65                                             */
     /* Sample output: "passed"                                      */
     /* ------------------------------------------------------------ */
   
     // include I/O library

     // declare variables: float score
   
     // ask for score between 0 and 100

     // get user input from keyboard
       
     // compute result

     // stream result to screen
     #+end_example

     #+begin_quote
     - Pros: program header useful (later), includes input/output,
       variable detail; good for planning the whole program
     - Cons: lacks focus on algorithm (still no detail here); detail
       obscures logic of the solution
     #+end_quote

  3) Third attempt:
     #+begin_example
     // If grade is greater or equal to 60
        // print "passed"

     // else
        // print "failed"
     #+end_example

     #+begin_quote
     - Pros: clarifies algorithm without getting bogged down in syntax
       (but suggests enough syntax to remember/structure the code)
     - Cons: Leaves out "standard stuff" (like I/O), problematic for
       beginners only.
     #+end_quote

  4) Implementation with comments:
     #+begin_src C++ :cmdline < ../data/score :main no :includes <iostream> :namespaces std :results output :exports both
       /* ------------------------------------------------------------ */
       /* Get score from user and return "passed" or "failed" message. */
       /* Sample input: 65                                             */
       /* Sample output: "passed"                                      */
       /* ------------------------------------------------------------ */
       #include <iostream> // include I/O library

       int main() { 
         // declare variables: float score
         float score;
         // ask for score between 0 and 100
         cout << "Enter score between 0 and 100: ";
         // get user input from keyboard
         cin >> score;
         // compute result
         cout.precision(3); // set output precision
         // If grade is greater or equal to 60
         if (score >= 60) {
           cout << "\n" << score << ": passed" << endl;  // print "passed"
         } else {
           cout << "\n" << score << ": failed" << endl;  // print "failed"
         }
         return 0;
       }
     #+end_src

     #+RESULTS:
     : Enter score between 0 and 100: 
     : 65: passed

     Input file:
     #+begin_src bash :results output :exports both
       echo "65" > ../data/score
       cat ../data/score
     #+end_src

     #+RESULTS:
     : 65

* IN PROGRESS Debugging
* IN PROGRESS Exercises

1. fix program (syntax)

2. fix code chunk (missing main)

3. Print the integer 5 in two different ways.

   Solution:
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     printf("%d\n", 5);
     cout << 5 << endl;
   #+end_src

   #+RESULTS:
   : 5
   : 5

4. Declare and initialize the following variables in as few lines as
   possible: c as 'a', i as -1000, k as 150, x as 2.5, b as false, and
   then print them using =cout=.

   Solution:
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     char c = 'a';
     int i = -1000, k = 150, b = 0;
     float x = 2.5;
     // bool b = false;
     cout << c << " " << i << " " << k << " " << x << " " << b << endl;
   #+end_src

   #+RESULTS:
   : a -1000 150 2.5 0

5. Can you change the program to represent the following statement:
   "When the sun shines, it's sunny; otherwise, when it rains, it's
   rainy; otherwise, it's neither sunny nor rainy." Run the program
   with these values:
   1) no sun, no rain
   2) no sun, but rain
   3) both sun and rain

   Solution:
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     bool sun = false, rain = true;
     if (sun == true) printf("It's sunny.");
      else if (rain == true) printf("It's rainy");
      else printf("It's neither sunny nor rainy.");
   #+end_src

   #+RESULTS:
   : It's rainy

6. Put this into code using Boolean variables and condition
   statements: "Socrates is a man. All men are mortal. Therefore,
   Socrates is mortal."

   Solution:
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     // premise
     bool SocratesIsAman = true, menAreMortal = true;
     // conclusion
     if (SocratesIsAman == true and menAreMortal == true) {
       printf("Socrates is mortal.");
      }
   #+end_src

   #+RESULTS:
   : Socrates is mortal.

7. Write a step function that accepts all arguments, not just integer
   ones. Test it for the sample values -0.5, 0, 0.5. Do not declare
   and define an extra variable as result in the function, reduce the
   length of the previously defined function from 7 to 3 lines, and
   the length of the =main= function from 4 to 2 lines.

   Solution:
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     // define step function
     int step(double x) {
       if (x > 0) return 1;
       else if (x == 0) return 0;
       else return -1;
     }
     // main function
     int main() {
       cout << step(-0.5) << "\n"
            << step(0) << "\n"
            << step(0.5) << endl;
       return 0;
     }
   #+end_src

   #+RESULTS:
   : -1
   : 0
   : 1

8. Print the following constants[fn:4] (and the corresponding
   headlines) using first =printf= and then =cout=. 
   #+begin_example
     Print with `cout`:
     3.141592654
     2.718281828
     0.007297352564
    
     Print with `printf`
     3.14159265
     2.7182818
     7.297352564300e-03
   #+end_example

   Solution:
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     // define constants
     const double pi = 3.141592653589793; // pi
     const double e  = 2.718281828459045; // Euler number
     const double a  = 7.2973525643E-03; // fine structure constant     
     //const double a  = 0.0072973525643; // fine structure constant
     // print values with cout
     cout.precision(10);
     cout << "Print with `cout`:" << endl;
     cout << pi << endl
     << e  << endl
     << a  << endl;
     cout << endl;
     // print values with printf
     printf("Print with `printf`\n"); 
     printf("%.8f\n",pi);
     printf("%.7f\n",e);
     printf("%.12e\n",a);     
   #+end_src

   #+RESULTS:
   : Print with `cout`:
   : 3.141592654
   : 2.718281828
   : 0.007297352564
   : 
   : Print with `printf`
   : 3.14159265
   : 2.7182818
   : 7.297352564300e-03

9. Create a commented version of the ~step~ function program written
   earlier: comment every line of the program, and include a header
   with multiline comments.

   Solution
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     /* ------------------------------------------- */
     /* Define a step function with the values      */
     /* f(x == 0) = 0, f(x < 0) = -1, f(x > 0) = 1  */
     /* Sample input: x = {-0.5, 0, 0.5}            */
     /* Author: Marcus Birkenkrahe (2024)           */
     /* ------------------------------------------- */
     // define step function: 
     int step(double x) { // return one integer, take one double argument
       if (x > 0) return 1; // when x is positive, return the value 1
       else if (x == 0) return 0; // when x is zero, return the value 0
       else return -1; // when x is negative, return the value -1
     } // end of function
     // main function
     int main() { // return one integer, take no arguments
       cout << step(-0.5) << "\n" // call step on value, print value, newline
            << step(0) << "\n" // call step on value, print value, newline
            << step(0.5) << endl; // call step on value, print value, newline
       return 0; // return 0 if program ran successfully
     } // end of main function
   #+end_src

10. (debugging)

* IN PROGRESS Review questions

1) [Emacs and Org-mode]

2) [code chunk]

3) What's the difference between these three statements, and what will
   the output be?
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     cout << "One" << endl;
     cout << "Two" << "\n";
     std::cout << "Three" << std::endl;
   #+end_src

   #+RESULTS:
   : One
   : Two
   : Three

4) What is a named object also called?
   #+begin_quote
   A variable.
   #+end_quote

5) What are the logical parts of the statement "The grade will be good
   when the student studies"?
   #+begin_quote
   - The premise: "The student studies."
   - The conclusion: "The grade will be good."
   #+end_quote
   
6) What's the meaning of =public= and =private= states?
   #+begin_quote
   Public states are visible, private states are hidden.
   #+end_quote

7) What's a "class diagram"?
   #+begin_quote
   A static structure diagram in the Unified Modeling Language (UML)
   that describes the structure of a system by showing attributes (or
   states), methods (or behavior), and the relationships among
   objects, and indicates if attributes and methods are public or
   private.
   #+end_quote

8) How do you know the =return= value of a function?
   #+begin_quote
   The first term of the function definition, unless =void=, specifies
   the =return= value, e.g. =int= for an integer =return= value.
   #+end_quote

9) How many values can a function =return=?
   #+begin_quote
   A function can only =return= a single value directly, but that single
   value can be a container that holds multiple values (see example).
   #+end_quote
   Example:
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
     #include <vector>
     // function definition
     vector<int> count() {
       static int a[5]{100,200,300,400,500}; // declare array of integers
       return vector<int>(a, a + 5); // create and return vector from array
     }
     //
     int main() {
       // call function and store returned vector in result
       vector<int> result = count();
       // print invidual vector elements using a range-based for loop
       for (int value : result) {
         cout << value << " ";
       }
       return 0;
     }
   #+end_src

   #+RESULTS:
   : 100 200 300 400 500 

10) [debugger]

* Glossary

| Term           | Definition                                                       |
|----------------+------------------------------------------------------------------|
| main           | Program entry point in C++                                       |
| #include       | Preprocessor directive to include libraries                      |
| printf         | Function to print formatted output                               |
| cout           | Standard output stream                                           |
| endl           | Add new line                                                     |
| int            | Integer data type in                                             |
| void           | Specifies that a function takes no arguments or returns no value |
| std::endl      | Manipulator to insert a newline character and flush the stream   |
| gcc            | GNU Compiler Collection for compiling C/C++ programs             |
| Emacs          | Editor for creating source code                                  |
| bash           | Shell for running executable files                               |
| linker         | Tool to link libraries to the source code                        |
| compiler       | Tool to turn source code into executable code                    |
| library        | Collection of pre-compiled routines used in programming          |
| Org-mode       | An Emacs mode for keeping notes, planning, authoring documents   |
| code chunk     | A block of code within a document (Org-mode)                     |
| header         | The top of a code chunk specifying its parameters (Org-mode)     |
| return         | Statement to exit a function and optionally pass back a value    |
| function       | A block of code designed to perform a specific task              |
| C++            | An object-oriented (OO) programming language.                    |
| OOP language   | A programming language that supports objects                     |
| object         | Abstract entity with a state (attribute) and behaviour (method)  |
| state          | The attribute or feature of an object, representing what it is   |
| behavior       | The method or function of an object, representing what it can do |
| type           | The collection of behaviors and states that describe an object   |
| strongly typed | A language in which each object has a predefined data type       |
| int            | Represents the built-in integer type in C++                      |
| variable       | A named object used to store data                                |
| class diagram  | Static structure diagram in the Unified Modeling Language (UML)  |

* Summary


** Presentation of Content (20 minutes)
*** C++ Syntax


#+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
  int main() {
    cout << "Hello, World!" << endl;
    return 0;
  }
#+end_src

*** Variables and Data Types

- Variables store data values in memory
- Variables must be declared before they can be used.
- Basic data types: =int=, =float=, =double=, =char=, =bool=

#+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
  int main() {
    int age = 25;
    float height = 5.9;
    double pi = 3.14159;
    char grade = 'A';
    bool is_student = true;

    cout << "Age: " << age << endl;
    cout << "Height: " << height << endl;
    cout << "Pi: " << pi << endl;
    cout << "Grade: " << grade << endl;
    cout << "Is Student: " << is_student << endl;

    return 0;
  }
#+end_src

*** Operators
- Arithmetic operators: +, -, *, /, %
- Comparison operators: ==, !=, >, <, >=, <=
- Logical operators: &&, ||, !

#+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
  int main() {
    int a = 10, b = 20;
    cout << "a + b = " << (a + b) << endl;
    cout << "a - b = " << (a - b) << endl;
    cout << "a * b = " << (a * b) << endl;
    cout << "a / b = " << (a / b) << endl;
    cout << "a % b = " << (a % b) << endl;

    cout << "a == b: " << (a == b) << endl;
    cout << "a != b: " << (a != b) << endl;
    cout << "a > b: " << (a > b) << endl;
    cout << "a < b: " << (a < b) << endl;

    bool result = (a < b) && (b > 15);
    cout << "(a < b) && (b > 15): " << result << endl;

    return 0;
  }
#+end_src

** Practice Exercises (30 minutes)

- Write a program to declare and initialize variables of different
  (fundamental or primitive) data types and print them.

- Write this as an Emacs .org file with a header (substitute [...]):
  #+begin_example
  #+TITLE: [title]
  #+AUTHOR: [your name] (pledged)
  #+SUBTITLE: [class and topic]
  #+end_example

*** Solution:

See file: tinyurl.com/alg1-first

Fundamental data types in C++ are: integer =int=, floating-point =float=
and =double=, character =char=, and Boolean =bool=.

#+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both

#+end_src

- Create a simple calculator program using arithmetic operators

  Solution:

- Compare two integers using comparison operators and print the
  results

  Solution:

- Combine logical operators to evaluate and print the truth value of
  expressions

  Solution:

** Q&A and Discussion (15 minutes)
- Open floor for questions and clarifications
- Discuss common issues faced during practice exercises
- Provide additional examples or explanations as needed
* References

- This section losely follows chapter 1 (pp. 50-76) of the "C++ Crash
  Course: A Fast-Pace Introduction" by J Lospinoso (NoStarch,
  2019). The section "Comments (and Pseudocode)" uses an example by
  Smith (2023). "The Rook's Guide to C++" by Jensen (2013) was also
  used.

- Bastani, Hamsa and Bastani, Osbert and Sungu, Alp and Ge, Haosen and
  Kabakcı, Özge and Mariman, Rei, Generative AI Can Harm Learning
  (July 15, 2024). [[https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4895486&s=03#][Available at ssrn.com]].

- Jensen (2013). The Rook's Guide to C++. URL: [[https://rooksguide.org/wp-content/uploads/2013/12/rooks-guide-isbn-version.pdf][rooksguide.org]].

- Smith (February 23, 2023). Learn to Write Pseudocode: What It Is and
  Why You Need It. URL: [[https://wikihow.com/Write-Pseudocode][wikihow.com/Write-Pseudocode]].

* Footnotes

[fn:4]These constants are: Pi, the Euler number (exp(1)), and the
fine-structure (or Sommerfeld) constant, the strength of the
electromagnetic interaction between elementary charged particles.

[fn:3]Step functions are important e.g. as activation functions for
neural nets, in signal processing and digital circuits, and wherever
abrupt changes are being modeled.

[fn:2]The source code is completed using the header arguments (if any)
to create a source file, which is handed over to the compiler. If this
file is syntactically correct, it will compile, and then run. Emacs
does all of this in the background. Since C++ is a compiled, not an
interpreted language (like Python or R), there is no continuous
session.

[fn:1]To render the =dot= language in Emacs, you need to install
graphviz (=sudo apt install graphviz=), and add =(dot . t)= to the other
languages already loaded in your =.emacs= configuration file.
