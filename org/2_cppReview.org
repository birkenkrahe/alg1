#+TITLE:C++ Basics review
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:CSC 240 - Data structures with C++ - Lyon College, FA24
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:C++ :main yes :includes <iostream> :results output :exports both :noweb yes
* Overview

Fast paced C++ review and overview including:
1) Structure of C++ programs
2) "Hello world" sample program

* The Structure of a Basic C++ Program

- What is required to create and run a C++ program?
  #+begin_quote
  1. An editor to create the source code (like Emacs).
  2. A compiler to turn the source code into executable code (like GCC).
  3. A linker to link libraries (like =iostream=) to the source code file.
  4. A shell (or an IDE with a shell) to run the executable (like =bash=).
  #+end_quote

- What must every C++ program have?
  #+begin_quote
  A =main= function. Optional: Preprocessor directives (like =#include=).
  #+end_quote

* A first C++ program in six incarnations

For this section, fire up Emacs, open a file (~C-x C-f first.org RET)~
and code along. To create a C++ code block, enter ~<s TAB C++~.

1) Example: "Hello world" program - can you explain every line?
   #+begin_src C++ :results output :exports both
     #include <cstdio>

     int main() {

       printf("Hello, world!");

       return 0;
     }
   #+end_src

   #+RESULTS:
   : Hello, world!

2) A good habit: Provide ample comments (espcially at the beginning)
   #+begin_src C++ :results output :exports both
     /* --------------------------------------------*/
     /* Print a string to a standard output device  */
     /* --------------------------------------------*/
     // include standard input/output library
     #include <cstdio>
     // main program
     int main() {  // return integer, take no argument (void)
       // print string
       printf("Hello, world!");
       // return 0 if successful
       return 0;
     } // end of main program
   #+end_src

   #+RESULTS:
   : Hello, world!

3) Here is another version: What's different?
   #+begin_src C++ :results output :exports both
     /* --------------------------------------------*/
     /* Print a string to a standard output device  */
     /* Use character array and formatted printing  */
     /* --------------------------------------------*/
     #include <cstdio>
     // main program
     int main() {  // return integer, take no argument (void)
       // declare and initialize character array
       char greeting[] = {"Hello, world!"};
       // print string
       printf("%s\n", greeting);
       // return 0 if successful
       return 0;
     } // end of main program
   #+end_src

   #+RESULTS:
   : Hello, world!

4) And another version: What's different?
   #+begin_src C++ :results output :exports both
     /* --------------------------------------------*/
     /* Print a string to a standard output device  */
     /* Use iostream and stream extraction cout <<  */
     /* --------------------------------------------*/
     #include <iostream>
     // main program
     int main() {  // return integer, take no argument (void)
       // print string
       std::cout << "Hello, world!" << std::endl;
       // return 0 if successful
       return 0;
     } // end of main program
   #+end_src

   #+RESULTS:
   : Hello, world!

5) With the magic of Emacs + Org-mode, one could almost believe that
   C++ was Python or R - what's different?
   #+begin_src C++ :main yes :includes <iostream> :namespaces std :tangle hw.cpp :results output :exports both
     // print string to standard output device
     cout << "Hello, world!" << endl;
   #+end_src

   #+RESULTS:
   : Hello, world!

6) Literate programming: The last code block can be "tangled" into
   source code:
   #+begin_src bash :results output :exports both
     cat hw.cpp
   #+end_src

7) The source code file can be compiled and run on the command line (or
   in a shell in this Org-mode file):
   #+begin_src bash :results output :exports both
     g++ -o hello hw.cpp
     ./hello
   #+end_src

   #+RESULTS:
   : Hello, world!

* A note on using AI to write code for you or debug your mistakes

- Question from a Lyon graduate who now works as a software engineer,
  who asked for my recommendation regarding use of AI:
  #+begin_quote
  "I was wondering if you could give me any guidance. We are changing the
  way that we store stuff in our warehouse. They asked me if it would be
  possible to run some code with an AI to see what it would say. I asked
  ChatGPT and it gave me a pretty simple solution which involved getting
  the size, frequency grabbed, etc."
  #+end_quote

- What do you think? Let's hear your answers:
  1) Should a software engineer use AI to get ideas or improve his code?
  2) Are there any potential issues with this approach?
  3) Do you think AI will change software engineering, and how?
  4) Should you use AI to let it help you learn in technical classes?

- My answers (short version):
  #+begin_quote
  1) He should only use AI if he does not care about the result - if
     he does not depend on it, and if he has ample time to waste.
  2) AI lies unpredictably, often delivers misguided output, makes you
     forget stuff you already knew, and gives you a false sense of
     security. It's like having a slave who really wants to help but
     is incapable of having even a single thought of his own.
  3) It has already changed software engineering though there are no
     good studies yet, only a lot of calls for research. The pace of
     development of these principally intransparent tools is too fast.
  4) No unless you have a lot of time to waste and/or already know
     your stuff really well (and even then, it's dangerous).
  #+end_quote

- Here is my very long answer to the guy for the record:
  #+begin_quote
  Use AI for things you really don't care about, and if you don't care
  how much time you waste, because while the code it produces can be
  debugged, you will not know when and where the AI "hallucinates"
  i.e. spews nonsense. As a result, it may be hard to debug since you
  cannot talk to it about its own mistakes as you would to a
  coworker. AI aims to please you at any cost and has no insight or
  understanding of what it does at all. Syntax errors are less likely,
  version and dependency errors are frequent (since it doesn't test
  its own code). Logic errors are brutal and hard to find and you may
  spend precious time dealing with the AI that you could have used to
  learn something new or test or create yourself (which would have
  taught you something). If you keep using it for things that are
  easy, you'll forget what you once knew. It's worse than
  copy-and-paste because it will always try to give you the whole
  thing, and copy-and-paste programming at least forces you to think
  the code through that you copied (ideally anyway). It is probably OK
  (haven't tried it) when it comes to web stuff since web stuff is
  easy. But it'll likely fail when you try it on anything that's
  complex (of course it has got better, too, over the past year, but
  only marginally, in this regard). In terms of raw code, its
  solutions are often not as easy as they could be, use the wrong data
  structures, have no concern for performance, and generally will mess
  with your own style - without offering anything in return (like a
  better or different style, which would happen if you worked with a
  human master programmer). Slight changes here depending on the
  language: C/C++ have lots of issues, Python probably the best (most
  public code examples I presume), SQL and R are pretty good (because
  they're simple and well-documented).

  Having said that, I use it a lot (as I say in the talk) but only for
  stuff I don't care about very much, and also I am often not a slave
  to deadlines like you, and I have decades more experience to cut
  through the BS that I'm given. I use it when I'm lazy in the full
  knowledge that I may have to start all over, and to give me an
  alternative (which sometimes works), or sometimes because I'm lonely
  (unlike you I have nobody who programs with or alongside me). When
  AI teaches me something new, I have to re-learn it just as if I had
  heard it in a lecture or in a video (and check carefully).
  #+end_quote

- I have spoken about this at length at Oklahoma University last March ([[https://mediasite.ouhsc.edu/Mediasite/Channel/python/watch/356583673e7e40a1828990acb60f7f061d][link]]).

- Some recent evidence in a home debugging story:
  #+begin_quote
  I set up a new workstation at home with a Linux distro that I had
  not used before. After installing Emacs from scratch, I got the
  error message: ~"Invalid function: org-assert-version"~, which relates
  to a function in the Org-mode package and disabled many other
  commands at once. ChatGPT's advice was lengthy, involved
  re-installing software packages and peppering the Emacs
  configuration file with new functions. I put all of these
  suggestions to work since I didn't want to think about it - I just
  wanted to be done with (after many hours of installing things, late
  at night). The next morning I did not open the AI and just looked at
  the files that Emacs complained about, and that coud not be
  processed. I immediately saw that there was an empty line where
  Emacs did not expect to find one (Org-roam expects to find an ID in
  the first line of the file). I had inadvertently created that empty
  line earlier when editing something. This is the old way - thinking
  about errors, getting frustrated, taking the error to bed and
  mulling it over, sometimes for hours, while doing something else in
  the meantime. Then, always, the answer "presents itself", or rather,
  it is generated by your wetware, your beautiful, God-given brain.
  #+end_quote

- Short summary: At your stage, using AI is a waste of time at best,
  and a crime against your ability to learn at worst. Learning never
  comes without pain and (temporary) desperation. AI is like a pill
  but one that only works some of the time, and you'll never know
  when. Instead: join Lyon's Programming Student Club and experience
  the pain of not knowing first hand every week!

- You don't have to believe me - experiment with it on your own but
  make sure that you don't get addicted to the convenience of AI.

- Will you be punished for using AI in my class?
  #+begin_quote
  Not directly because nobody can tell if you used AI or not but
  indirectly by turning in suboptimal results, by learning less, and
  by having less time for other, more productive activities.
  #+end_quote

- Are there any data on this?
  #+begin_quote
  Not much on coding per se but a recent (15 July), substantive, long
  (59 p) paper titled "Generative AI Can Harm Learning"), based on a
  very carefully conducted field experiment with a large (1000) sample
  of high school students concluded: "Our results suggest that
  students attempt to use [AI] as a "crutch" during practice problem
  sessions, and when successful, perform worse on their own. Thus, to
  maintain long-term productivity, we must be cautious when deploying
  generative AI to ensure humans continue to learn critical skills."
  ([[https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4895486&s=03][Bastani et al, 2024]]).
  #+end_quote

* =main=

- All C++ programs have a single entry point called the =main= function.

- Functions are blocks of code that can take input and return results:
  #+begin_src C++ :tangle hw2.cpp :main no :includes <iostream> :namespaces std :results output :exports both
    void hello() { // function declaration and definition
      cout << "hello" << endl;
    }
    main() { // program entry point
      hello();  // function call
    }
  #+end_src

  #+RESULTS:
  : hello

- Look at the tangled file:
  #+begin_src bash :results output :exports both
    cat hw2.cpp
  #+end_src

- When you define your own functions (or classes and their member
  functions), you need to declare them before =main= (you can define
  them after):
  #+begin_src C++ :tangle hw2.cpp :main no :includes <iostream> :namespaces std :results output :exports both
    void hello(); // function declaration (prototype)

    int main() { // program entry point
      hello();  // function call
      return 0;
    }

    void hello() { // function definition
      cout << "hello" << endl;
    }
  #+end_src

  #+RESULTS:
  : hello

* NEXT =#include=

* =namespace=

* The C++ Type System
* Declaring Variables
* Initializing a Variable's State
* Conditional Statements
* Functions
* Print format specifiers
* Comments
* Debugging
* Glossary

* Summary


** Presentation of Content (20 minutes)
*** C++ Syntax


#+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
  int main() {
    cout << "Hello, World!" << endl;
    return 0;
  }
#+end_src

*** Variables and Data Types

- Variables store data values in memory
- Variables must be declared before they can be used.
- Basic data types: =int=, =float=, =double=, =char=, =bool=

#+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
  int main() {
    int age = 25;
    float height = 5.9;
    double pi = 3.14159;
    char grade = 'A';
    bool is_student = true;

    cout << "Age: " << age << endl;
    cout << "Height: " << height << endl;
    cout << "Pi: " << pi << endl;
    cout << "Grade: " << grade << endl;
    cout << "Is Student: " << is_student << endl;

    return 0;
  }
#+end_src

*** Operators
- Arithmetic operators: +, -, *, /, %
- Comparison operators: ==, !=, >, <, >=, <=
- Logical operators: &&, ||, !

#+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both
  int main() {
    int a = 10, b = 20;
    cout << "a + b = " << (a + b) << endl;
    cout << "a - b = " << (a - b) << endl;
    cout << "a * b = " << (a * b) << endl;
    cout << "a / b = " << (a / b) << endl;
    cout << "a % b = " << (a % b) << endl;

    cout << "a == b: " << (a == b) << endl;
    cout << "a != b: " << (a != b) << endl;
    cout << "a > b: " << (a > b) << endl;
    cout << "a < b: " << (a < b) << endl;

    bool result = (a < b) && (b > 15);
    cout << "(a < b) && (b > 15): " << result << endl;

    return 0;
  }
#+end_src

** Practice Exercises (30 minutes)

- Write a program to declare and initialize variables of different
  (fundamental or primitive) data types and print them.

- Write this as an Emacs .org file with a header (substitute [...]):
  #+begin_example
  #+TITLE: [title]
  #+AUTHOR: [your name] (pledged)
  #+SUBTITLE: [class and topic]
  #+end_example

*** Solution:

See file: tinyurl.com/alg1-first

Fundamental data types in C++ are: integer =int=, floating-point =float=
and =double=, character =char=, and Boolean =bool=.

#+begin_src C++ :main yes :includes <iostream> :namespaces std :results output :exports both

#+end_src

- Create a simple calculator program using arithmetic operators

  Solution:

- Compare two integers using comparison operators and print the
  results

  Solution:

- Combine logical operators to evaluate and print the truth value of
  expressions

  Solution:

** Q&A and Discussion (15 minutes)
- Open floor for questions and clarifications
- Discuss common issues faced during practice exercises
- Provide additional examples or explanations as needed
* References

- This section losely follows chapter 1 (pp. 50-76) of the "C++ Crash
  Course: A Fast-Pace Introduction" by J Lospinoso (NoStarch, 2019).

- Bastani, Hamsa and Bastani, Osbert and Sungu, Alp and Ge, Haosen and
  Kabakcı, Özge and Mariman, Rei, Generative AI Can Harm Learning
  (July 15, 2024). [[https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4895486&s=03#][Available at ssrn.com]].
