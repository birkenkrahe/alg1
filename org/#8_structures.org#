#+title: Strings
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:C :main yes :includes <stdio.h> <stdlib.h> <string.h> <time.h> :results output :exports both :comments none :noweb yes

* Motivation

- There are three user-defined data structures that help organize data
  and group them logically:

  | Data Structure | Explanation                                                   |
  |----------------+---------------------------------------------------------------|
  | =struct=         | Different types. Each member has its own memory location.     |
  | =enum=           | Assigns names to integer constants. All members are integers. |
  | =union=          | Groups variables, members share the same memory location.     |

  | Data Structure | Use Cases                                                     |
  |----------------+---------------------------------------------------------------|
  | =struct=         | Complex objects like points, employees, or students.          |
  | =enum=           | Fixed sets of values (days of the week, states, error codes). |
  | =union=          | Optimizing memory usage.                                      |

- Structures are by far the most important so we'll spend most of our
  time on them.

* First examples

- Structure example: A point is defined as a pair of (x,y)
  values. Once the =struct= is defined, =Point= can be used like any other
  data type.
  #+begin_src C
    struct Point {
      int x;
      int y;
    };

    int main() {
      struct Point p1 = {10, 20};
      printf("Point: (%d, %d)\n", p1.x, p1.y);
      return 0;
    }
  #+end_src

  #+RESULTS:
  : Point: (10, 20)

- Enumeration example: The =enum= =Day= is an integer type whose values
  are named.
  #+begin_src C
    #include <stdio.h>
    enum Day { MON, TUE, WED, THU, FRI, SAT, SUN };

    int main() {
      enum Day today = WED;
      printf("Today is day number: %d\n", today); // Output: 2 (WED)
      return 0;
    }
  #+end_src

  #+RESULTS:
  : Today is day number: 2

- Union example: Similar to a structure except that its members share
  the same storage so that only one member can be stored at a time.
  #+begin_src C
    union Data {
      int i;
      float f;
      char str[20];
    };

    int main() {
      union Data data;
      data.i = 42;
      printf("Integer: %d\n", data.i);

      data.f = 3.14;
      printf("Float: %f\n", data.f);

      strcpy(data.str,"hello");
      printf("String: %s\n", data.str);

      return 0;
    }
  #+end_src

  #+RESULTS:
  : Integer: 42
  : Float: 3.140000
  : String: hello

* Structure variables

- So far, we've only covered one data structure, the array. Array
  elements all must have the same type and they can be subscripted.

- Structure members can have different types, and they have names,
  which we use rather than their position.

- Most high level languages provide this feature:
  1. In C++, the =class= is an extension of the =struct= with the
     difference that its members are =private= by default.
  2. In R, the =list= is a =struct= without methods (with with =apply=), and
     custom methods can be defined.
  3. In SQL, the =table= schema is a =struct= (without methods). Foreign
     keys link tables like pointers in C.

* Declaring structure variables

- Structures are for storing a collection of related data items - for
  example parts in a warehouse, represented by:
  1) Part =number= (integer)
  2) Part =name= (string)
  3) Number of parts =on_hand= (integer)

- In code:
  #+name: parts
  #+begin_src C :results none
    #define NAME_LEN 25

    struct {
      int number; // parts number
      char name[NAME_LEN+1]; // parts name - string + null character
      int on_hand; // part is on hand
    } part1, part2; // two part variables
  #+end_src

- Members are stored in memory in the order in which they are declared:
  #+attr_html: :width 250px:
  [[./img/struct.png]]

- Here, =number= and =on_hand= occupy 4 bytes (=int=), and =name= occupies 25
  bytes (=char= has 1 byte x 25).

- Usually, structures are represented by adjacent vertical or
  horizontal boxes:
  #+attr_html: :width 600px:
  [[./img/struct2.png]]

- Structure scope: Each structure represents a new block scope, and
  its names will not conflict with other names in a program. This is
  also called a =namespace=.

- You remember this concept from beginner's C++: By declaring the
  namespace =std= at the start, you don't have to write =std::cout= and
  =std::endl=.
  #+begin_src C++ :includes <iostream>
    using namespace std;

    cout << "hello name space" << endl;

  #+end_src

  #+RESULTS:
  : hello name space

* Using a structure

- Now let's use this parts structure:
  #+begin_src C
    #define NAME_LEN 25

    // declare structure
    struct {
      int number; // parts number
      char name[NAME_LEN+1]; // parts name - string + null character
      int on_hand; // how many parts are available
    } part1, part2; // two parts

    // main program
    int main(void)
    {
      // use parts structure
      strcpy(part1.name, "Printer cable"); // cannot copy string array
      part1.number = 528;
      part1.on_hand = 10;

      // print part1 data
      printf("Part: %s, number = %d, on hand = %d\n",
         part1.name, part1.number, part1.on_hand);

      return 0;
    }
  #+end_src

  #+RESULTS:
  : Part: Printer cable, number = 528, on hand = 10

* Practice: Create and test an employee database structure

- Replicate this code for another structure that contains the
  following information on employees: =number=, =name=, and =sex=. Define
  two employees, =employee1= and =employee2=.

  When the code compiles, test the structure in a =main= program for
  =employee1= whose name is "Fritz Fisch", who is male and has the
  employee number 205482.

- Generate the output:
  #+begin_example
    Employee: Fritz Fisch, number = 285942, sex = M
  #+end_example

- Solution:
  #+begin_src C
    #define NAME_LEN 25

    // declare structure
    struct {
      char name[NAME_LEN+1];
      int number;
      char sex;
    } employee1, employee2; // two employees

    // main program
    int main(void)
    {
      // use employee structure
      strcpy(employee1.name, "Fritz Fisch");
      employee1.number = 285942;
      employee1.sex = 'M';

      printf("Employee: %s, number = %d, sex = %c\n",
         employee1.name, employee1.number, employee1.sex);

      return 0;
    }
  #+end_srcn

  #+RESULTS:
  : Employee: Fritz Fisch, number = 285942, sex = M

* Initializing structure variables

- A structure declaration may include an initializer.

- Non-initialized members are set to 0.

- Initializers can be /positional/ (same order as in declaration), or
  /designated/ (any order as long as they're named): In the code below,
  =part1= is initialized with a designator, while =part2= is not.

  #+begin_src C
    #define NAME_LEN 25
    struct {
      int number;
      char name[NAME_LEN+1];
      int on_hand;
    } part1 = {.name = "Disk drive", .on_hand = 10, .number = 528},
      part2 = {914, "Printer cable"};

    printf("Part 1: %s, number = %d, on hand = %d\n"
           "Part 2: %s, number = %d, on hand = %d\n",
           part1.name, part1.number, part1.on_hand,
           part2.name, part2.number, part2.on_hand);
  #+end_src

  #+RESULTS:
  : Part 1: Disk drive, number = 528, on hand = 10
  : Part 2: Printer cable, number = 914, on hand = 0

* Operations on structures

- The members of a structure are /lvalues/: they can appear left of an
  assignment, or as the operand in an increment/decremend expression:

- Like an array, a structure variable can be initialized and declared
  at once:

  #+begin_src C
    <<parts>> // declaration of parts only

    printf("part no. = %d\n",part1.number = 201);

    part1.number++;

    printf("part no. = %d\n",part1.number);
  #+end_src

  #+RESULTS:
  : part no. = 201
  : part no. = 202

- The period to access a structure is a C operator. It takes
  precedence over nearly all other operators. Other C-like languages
  with user-defined structures or classes have this dot-operator, too.

  Python example:
  #+begin_src python :python python3 :results output
    import numpy as np
    arr = np.array([1,2,3]) # use array method of numpy library
    print(arr)
  #+end_src

  #+RESULTS:
  : [1 2 3]

- In the following statement, the argument contains two operators: the
  "dot" operator takes precedence: =&= computes the address of =part.num=:
#+begin_example C
  scanf("%d", &part.num);
#+end_example

- We can show this by print address and value before and after the
  =scanf= command:

  #+begin_src bash :results output :exports both
    echo "1000" > input
    cat input
  #+end_src

  #+RESULTS:
  : 1000

  #+begin_src C :cmdline < input
    // declare structure
    struct {
      int num;
    } part = {.num = 999};

    // print structure member and address before user input
    printf("%p %d\n", &part.num, part.num);

    // get user input
    scanf("%d", &part.num);

    // print user input and address of user input
    printf("%p %d\n", &part.num, part.num);
  #+end_src

  #+RESULTS:
  : 0x7ffd12681ea4 999
  : 0x7ffd12681ea4 1000

- Though arrays cannot be copied using ===, structures can!

  #+begin_src C
    <<parts>>
    part1.number=415;
    strcpy(part1.name,"Keyboard");
    part1.on_hand=20;

    printf("Part 1: %s, number = %d, on hand = %d\n"
           "Part 2: %s, number = %d, on hand = %d\n",
           part1.name, part1.number, part1.on_hand,
           part2.name, part2.number, part2.on_hand);

    part2 = part1; // copy one structure into another

    printf("Part 1: %s, number = %d, on hand = %d\n"
           "Part 2: %s, number = %d, on hand = %d\n",
           part1.name, part1.number, part1.on_hand,
           part2.name, part2.number, part2.on_hand);
  #+end_src

  #+RESULTS:
  : Part 1: Keyboard, number = 415, on hand = 20
  : Part 2: , number = 2, on hand = 4096
  : Part 1: Keyboard, number = 415, on hand = 20
  : Part 2: Keyboard, number = 415, on hand = 20

- You can use this to copy arrays with dummy structures:
  #+begin_src C
    struct { int a[10]; } a1={1}, a2; puts("a1:");
    for(int *p=a1.a;p<a1.a+10;p++) printf("%d ",*p);
    puts("\na2:");
    for(int *p=a2.a;p<a2.a+10;p++) printf("%d ",*p);
    a2 = a1; puts("\na2:");
    for(int *p=a2.a;p<a2.a+10;p++) printf("%d ",*p);
  #+end_src

  #+RESULTS:
  : a1:
  : 1 0 0 0 0 0 0 0 0 0
  : a2:
  : 2 0 -1075053569 0 -22377815 32767 100 0 4096 0
  : a2:
  : 1 0 0 0 0 0 0 0 0 0

- No other operations but === are available. In particular, there is no
  way to compare structures with logical operators (==== and =!==).

- The === operator only works if the structures types /compatible/, which
  means that they must be declared at the same time.

* Structure types

- We need to define a name that represents the /type/ of structure, not
  a particular (anonymous) structure /variable/.

- We can either define a /structure tag/ or use /typedef/ to define a type
  name for our structure:

- This example declares a structure tag named =part=:
  #+name: part
  #+begin_src C :main no :results none
    #define NAME_LEN 25
    struct part {
      int number;
      char name[NAME_LEN+1];
      int on_hand;
    };  // semi-colon must terminate the declaration
  #+end_src

- The tag can now be used to declare variables:

  #+begin_src C :results none
    <<part>>

    struct part part1, part2; // must be prefixed by `struct`

  #+end_src

- Declaration of a tag and of structure variables can be combined:

  #+begin_src C
    #define NAME_LEN 25

    struct part {
      int number;
      char name[NAME_LEN+1];
      int on_hand;
    } part1 = {100,"keyboard",10};

    struct part part2;
    strcpy(part2.name,"screen");

    printf("Parts: %s and %s", part1.name,part2.name);
  #+end_src

  #+RESULTS:
  : Parts: keyboard and screen

- Alternatively, use =typedef= to define a genuine data type. All =Part=
  variables, no matter when they're declared, are compatible.

  #+begin_src C
    #define NAME_LEN 25

    typedef struct {
      int number;
      char name[NAME_LEN+1];
      int on_hand;
    } Part;  // define a type `Part`

    Part part1, part2; // declare variables
  #+end_src

- Declaring a structure tag is mandatory when the structure is used in
  a linked list.

* Practice: Creating a structure tag

1. Define a structure =Book= that has the following members:
   - An integer =id=.
   - A string =title= (with a maximum length of 50).
   - A float =price=.

2. Declare and initialize two =Book= variables:
   - =book1= with the =id= 101, =title= "C Programming", and =price= 29.99.
   - =book2= without initialization.

   #+name: Book_init
   #+begin_src C
     <<Book>>

     struct Book book1 = {101,"C Programming",29.99};
     struct Book book2;
   #+end_src

   #+RESULTS:

Solution:
#+name: Book
#+begin_src C :results none
  struct Book {
    int id;
    char title[50];
    float price;
  } book1 = {.id = 101, .title = "C Programming", .price = 29.99},
    book2;
#+end_src


#+begin_src C :tangle book.c
  <<Book>>

  book2.id = 102;
  strcpy(book2.title,"Data Structures");
  book2.price=39.99;

  printf("Book1: id = %d, title = %s, price = %g\n",
         book1.id, book1.title, book1.price);
  printf("Book2: id = %d, title = %s, price = %g\n",
         book2.id, book2.title, book2.price);
#+end_src

#+RESULTS:
: Book1: id = 101, title = C Programming, price = 29.99
: Book2: id = 102, title = Data Structures, price = 39.99

Bonus assignment (see next section):

1. Write a program to:
   - Print the details of =book1=.
   - Assign values to the members of =book2= (=id= 102, =title= "Data
     Structures", =price= 39.99).
   - Print the details of =book2=.

4. Use functions to:
   - Print the details of a =Book= structure.
   - Update the =price= of a book based on a percentage discount. 

* Structures as arguments and return values

- Functions may have structures as arguments and return values.

- Example: This function, when given a =Part= structure as its argument,
  prints the structure's members:

  #+begin_src C :tangle parts.c
    // Define a structure with a tag
    struct Part {
        int number; 
        char name[50];
        int on_hand; 
    };

    // Function to print a part
    void print_part(struct Part p)
    {
        printf("Part number: %d\n", p.number);
        printf("Part name: %s\n", p.name);
        printf("Quantity on hand: %d\n", p.on_hand);      
    }

    int main(int argc, char *argv[])
    {
        // Initialize part1
        struct Part part1 = {101, "Keyboard", 20};

        // Print part1 details
        print_part(part1);
        return 0;
    }
  #+end_src

  #+RESULTS:
  : Part number: 101
  : Part name: Keyboard
  : Quantity on hand: 20

- The second function returns a =Part= structure that it constructs from
  its arguments:

  #+begin_src C
    // Define a structure with a tag
    struct Part {
      int number; 
      char name[50];
      int on_hand; 
    };

    struct Part build_part(int number, const char *name, int on_hand)
    {
      struct Part p;  // declares part as Part

      p.number = number;
      strcpy(p.name, name);
      p.on_hand = on_hand;

      return p; // returns part
    }

    int main(int argc, char *argv[])
    {
      // Create a Part using the build_part function
      struct Part part1 = build_part(101, "Keyboard", 20);
      
      // Print part details
      printf("Part number: %d\n", part1.number);
      printf("Part name: %s\n", part1.name);
      printf("Quantity on hand: %d\n", part1.on_hand);
      
      return 0;
    }
  #+end_src

  #+RESULTS:
  : Part number: 101
  : Part name: Keyboard
  : Quantity on hand: 20

  
