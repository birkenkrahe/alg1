#+TITLE: Recursion
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: CSC 240 - Data structures with C++ - Lyon College, FA24
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:1 num:2 ^:nil
#+PROPERTY: header-args:C++ :main yes :includes <iostream> :results output :exports both :noweb yes
#+PROPERTY: header-args:C :main yes :includes <stdio.h> :results output :exports both :noweb yes
* Overview

- *Objectives:*
  + Compound literals to initialize arrays
  + Cast operators, lvalues and rvalues
  + Exiting from a function in the case of failure
  + Recursion principle with applications
  + Quicksort algorithm explained and coded
  + Code along and solve different exercises
  + Review questions, glossary, and summary

* Variable-Length Array Parameters

- Variable-length arrays allow to state the length of an array in a
  function argument. They are most useful for multidimensional arrays.

- In this function definition, there is no direct link between ~n~ and
  the length of the array ~a~. The array could in fact be larger or
  smaller than =n=, and then the function would not work (if =n= was used
  to access elements of =a=).
  #+begin_src C :results none
    int sum_array(int a[], int n) {
      // ...
    }
  #+end_src

- The array could be shorter or longer than =n= (and the function might
  break and lead to a "stack smashing" error because of an out of
  bounds array access:
  #+begin_src C :results none
    void foo(int a[], int n)
    {
      a[n]=0;
    }
    int main(void)
    {
      int a[2]={0};
      foo(a,2);
      return 0;
    }
  #+end_src

- Using a variable-length array parameter, we can explicitly state that
  the length of ~a~ is ~n~:
  #+begin_src C :results none
    int sum_array(int n, int a[]) {
      // ...
    }
  #+end_src

- But now the order of parameters is important: ~int n, int a[n]~ is OK,
  but ~int a[n], int n~ is illegal.

- *Practice:* Sum an array of length 10 without VLA (=sum_array=), and
  with VLA (=sum_array_vla=) then call the function with the values
  5,10,11 for n.
  #+begin_src C :main no :tangle vla.c
    int sum_array_vla(int n, int a[n]); // Variable-Length Array
    int sum_array(int a[], int n); // regular array

    int main(void)
    {
      int a[10]={[0 ... 9]=1}; // another way of initializing arrays
      printf("vla: %d\n", sum_array_vla(10,a));
      printf("regular: %d ", sum_array(a,11));
      return 0;
    }

    int sum_array_vla(int n, int a[n])
    {
      int i, sum=0;
      for (i=0;i<n;i++)
        sum+=a[i];
      return sum;
    }

    int sum_array(int a[], int n)
    {
      int i, sum=0;
      for (i=0;i<n;i++)
        sum+=a[i];
      return sum;
    }
  #+end_src

  #+RESULTS:
  : vla: 10
  : regular: 897987594 

- What did you find out?
  #+begin_quote
  The VLA generates a warning for n>10.
  #+end_quote

- Earlier, we summed the elements in a 2D array. The function [[sum2]] was
  limited to arrays with a fixed number of columns. With a VLA
  parameter, we can generalize the function to any number of columns:
  #+begin_src C :main no
    int sum_two_dimensional_array(int n, int m, int a[n][m]);

    int main(void)
    {
      int n = 4, m = 4, i, j;
      int a[n][m];
      for(i=0;i<n;i++) {
        for(j=0;j<m;j++) {
          a[i][j]=i+j;
          printf("%d ",a[i][j]);
        }
        printf("\n");
      }
      printf("Sum: %d\n", sum_two_dimensional_array(n, m, a));

      return 0;
    }

    int sum_two_dimensional_array(int n, int m, int a[n][m])
    {
      int i,j,sum=0;
      for(i=0;i<n;i++)
        for(j=0;j<m;j++)
          sum+=a[i][j];
      return sum;
    }
  #+end_src

  #+RESULTS:
  : 0 1 2 3 
  : 1 2 3 4 
  : 2 3 4 5 
  : 3 4 5 6 
  : Sum: 48

- Using keyboard input:
  #+name: sum_two_dimensional_array
  #+begin_src C :main no :tangle vlaSum.c :results none :flags -Wall -Wextra
    int sum_two_dimensional_array(int n, int m, int a[n][m]);

    int main(void)
    {
      int n, m, i, j; // n x m array, loop variables i, j

      printf("Enter number of rows and columns: ");
      scanf("%d %d", &n, &m);
      printf("%d %d", n, m);

      int a[n][m];
      puts("");

      for(i=0;i<n;i++) {
        for(j=0;j<m;j++) {
          a[i][j]=i+j;
          printf("%d ",a[i][j]);
        }
        printf("\n");
      }
      printf("Sum: %d\n", sum_two_dimensional_array(n, m, a));

      return 0;
    }

    int sum_two_dimensional_array(int n, int m, int a[n][m])
    {
      int i,j,sum=0;
      for(i=0;i<n;i++)
        for(j=0;j<m;j++)
          sum+=a[i][j];
      return sum;
    }
  #+end_src

- Testing:
  #+begin_src bash :results output
    gcc vlaSum.c -o vla
    echo 4 4 | ./vla
  #+end_src

  #+RESULTS:
  : Enter number of rows and columns: 4 4
  : 0 1 2 3 
  : 1 2 3 4 
  : 2 3 4 5 
  : 3 4 5 6 
  : Sum: 48

- Note: My first attempt at [[sum_two_dimensional_array]] failed with a
  "segmentation fault". The problem was that the array =a[n][m]= can
  only be declared *after* the user input =scanf= statement! To find
  issues like these, use additional compiler flags:
  #+attr_html: :width 600px:
  [[../img/compiler_flags.png]]

- These are all alternative ways to declare a VLA: the first one is to
  be preferred because it suggests the VLA, and also because the
  parameter list =int a[n], int n= is illegal (=n= is not known yet).
  #+begin_src C
    int func1(int n, int a[n]);
    int func2(int, int []);
    int func1(int n, int a[*]);
    int func1(int, int [*]);
  #+end_src

- VLA parameters can also be expressions to be evaluated, for example
  in this function where two arrays =a= and =b= are concatenated by
  copying them successively into an array =c=:
  #+begin_src C
    int concat(int m, int n, int a[m], int b[n], int c[m+n]);
  #+end_src

* Compound Literals

- The term 'literal' always refers to unchangeable language elements,
  and the term 'compound' means that keywords are combined, like in
  =i++=, the compound operator representing =i = i + 1=.

- When summing an array's elements in [[sum_array]], the array needs to be
  declared and initialized. Using a /compound literal/, this can be
  avoided:
  #+name: sum_array2
  #+begin_src C :main no
    // prototype declaration
    int sum_array2(int n, int a[n]);

    // main function
    int main()
    {
      printf("total = %d\n",
         sum_array2(5, (int []){3,0,3,4,1}));
      return 0;
    }

    // function definition
    int sum_array2(int n, int a[n])
    {
      int i, sum = 0;
      for (i=0;i<n;i++)
        sum += a[i];
      return sum;
    }

  #+end_src

  #+RESULTS: sum_array2
  : total = 11

- A compound literal resembles a cast =(int[])= applied to an
  initializer ={}=. It is also an /lvalue/, so the value of its elements
  can be changed. It can be made read-only by adding =const= before the
  type.

- An /lvalue/ (locator value) is an expression that points to a location
  in memory (that is it has an address):
  #+begin_src C :results none
    int x = 10; // x is an lvalue on the left of =
    x = x + 1; // x is an lvalue on the left and the right of =
  #+end_src

- An /rvalue/ (right-hand value) can only appear on the right of an
  assignment: It is a temporary value without a usable address.
  #+begin_src C :results none
    int y = 10 + 5; // `10 + 5` is an rvalue

    #define PI 3.14
    int x = PI; // PI is an rvalue because you cannot assign a value to it
    //PI = 3.15;
  #+end_src
  
- A /cast/ is an operator that converts one type into another:
  #+begin_src C
    int i = 1; // an integer 
    float x = 3.14; // a floating-point variable
    char c = 'a'; // a character variable
    char *ic = "22"; // a character pointer variable

    printf("%f\n", (float)(i)); // cast int to float (widening)
    printf("%d\n", (int)(x)); // cast float to int (narrowing/truncates)
    printf("%c\n",c); // no cast
    printf("%d\n",(int)(c)); // cast char to int
    printf("%i\n", atoi(ic)); // cast string (char pointer) to int
  #+end_src

  #+RESULTS:
  : 1.000000
  : 3
  : a
  : 97
  : 22

- =atoi= is a function from the C Standard Library (=stdlib.h=) that
  converts a numeric string into an integer value. The syntax looks
  like this:
  #+begin_example C
    int atoi(const char *str)
  #+end_example
  The argument is a constant pointer to a string. We'll learn more
  about strings later.

- An /lvalue/ or /locator value/ is an expression that represents a memory
  location, and that can appear on the left hand side of an assignment
  operator. As an object it persists beyond a single expression and
  can have a value assigned to it.

  By contrast, an /rvalue/ or /right value/ represents a data value stored
  in memory but that is not an assignable object itself.

  For example:
  #+begin_src C
    int x = 10;   // 'x' is an lvalue, '10' is an rvalue
    int *p = &x;  // 'p' is an lvalue, '&x' is an rvalue

    (*p) = 20;      // '*p' is an lvalue, '20' is an rvalue
    x = x + 5;    // 'x' is an lvalue, 'x + 5' is an rvalue
  #+end_src

- Are functions and operators the same thing, for example the
  functions =stdlib::atoi=, =stdio::printf= vs. the operators =sizeof= and
  =(int)=?
  #+begin_quote
  An operator is compiled to a sequence of instructions by the
  compiler. But if the code calls a function, it has to jump to a
  separate piece of code.
  #+end_quote

