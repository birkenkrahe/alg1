#+TITLE: Recursion (codealong I)
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: CSC 240 - Data structures with C++ - Lyon College, FA24
#+STARTUP:overview hideblocks indent
#+PROPERTY: header-args:C :main yes :includes <stdio.h> <stdlib.h> :results output :exports both :noweb yes
* Overview

- *Objectives:*
  + [ ] Variable-Length Array Parameters
  + [ ] Compound literals to initialize arrays
  + [ ] Cast operators, lvalues and rvalues

* Variable-Length Array Parameters

- Variable-length arrays allow to state the length of an array in a
  function argument. They are most useful for multidimensional arrays.

- No direct link between the array =a= and =n=:
  #+begin_src C :results none
    int sum_array(int a[], int n) {
      // ...
    }
  #+end_src

- Create a "stack smashing error":
  #+begin_src C :results none
    void foo(int a[], int n)
    {
      a[n] = 0;
    }
    int main(void)
    {
      int a[2]={0};
      foo(a,2); // if n = 2, array is out of bounds - stack smashing
      return 0;
    }
  #+end_src

- Using a variable-length array parameter, we can explicitly state that
  the length of ~a~ is ~n~:
  #+begin_src C :results none
    int sum_array(int n, int a[n]) {
      // ...
    }
  #+end_src

- But now the order of parameters is important: ~int n, int a[n]~ is OK,
  but ~int a[n], int n~ is illegal.

- *Practice:* Sum an array of length 10 without VLA (=sum_array=), and
  with VLA (=sum_array_vla=) then call the function with the values
  5,10,11 for n.
  #+begin_src C :main no :tangle vla.c
    int sum_array_vla(int n, int a[n]); // Variable-Length Array
    int sum_array(int a[], int n); // regular array

    int main(void)
    {
      int a[10]={ [0 ... 9] = 1 }; // another way of initializing arrays
      printf("vla: %d\n", sum_array_vla(11,a));
      printf("regular: %d ", sum_array(a,10));
      return 0;
    }

    // VLA parameter function
    int sum_array_vla(int n, int a[n]) // Variable-Length Array
    {
      int i, sum=0;
      for (i=0;i<n;i++)
        sum+=a[i];
      return sum;
    }
    // regular array function
    int sum_array(int a[], int n) // regular array
    {
      int i, sum=0;
      for (i=0;i<n;i++)
        sum+=a[i];
      return sum;
    }
  #+end_src

  #+RESULTS:
  : vla: 1375311114
  : regular: 10 

- What did you find out?
  #+begin_quote
  The VLA generates a warning for n out of bounds (n > 10).
  #+end_quote

- Two-dimensional arrays are not limited to fixed column numbers:
  complete the block to generate this output:
  #+begin_example
  : 0 1 2 3
  : 1 2 3 4
  : 2 3 4 5
  : 3 4 5 6
  : Sum: 48
  #+end_example

- Code:
  #+begin_src C :main no
    int sum_two_dimensional_array(int n, int m, int a[n][m]); // VLA

    int main(void)
    {
      int n = 4, m = 4, i, j;
      int a[n][m];

      for(i=0;i<n;i++) {  // loop over rows
        for(j=0;j<m;j++) { // loop over columns
          a[i][j]=i+j;  // add row and column index
          printf("%d ",a[i][j]);
        }
        printf("\n");
      }
      printf("Sum: %d\n", sum_two_dimensional_array(n,m,a));

      return 0;
    }

    int sum_two_dimensional_array(int n, int m, int a[n][m])
    {
      int i,j,sum=0;
      for(i=0;i<n;i++)
        for(j=0;j<m;j++)
          sum+=a[i][j];
      return sum;
    }
  #+end_src

  #+RESULTS:
  : 0 1 2 3 
  : 1 2 3 4 
  : 2 3 4 5 
  : 3 4 5 6 
  : Sum: 48

- Using keyboard input: Complete the =scanf= statement, then test the
  code for n = m = 4 using the shell code block below.
  #+begin_src C :main no :tangle vlaSum.c :results none
    int sum_two_dimensional_array(int n, int m, int a[n][m]);

    int main(void)
    {
      int n, m, i, j; // n x m array, loop variables i, j
      int a[n][m];

      printf("Enter number of rows and columns: ");
      scanf("%d %d",&n,&m);

      for(i=0;i<n;i++) {
        for(j=0;j<m;j++) {
          a[i][j]=i+j;
          printf("%d ",a[i][j]);
        }
        printf("\n");
      }
      printf("Sum: %d\n", sum_two_dimensional_array(n, m, a));

      return 0;
    }

    int sum_two_dimensional_array(int n, int m, int a[n][m])
    {
      int i,j,sum=0;
      for(i=0;i<n;i++)
        for(j=0;j<m;j++)
          sum+=a[i][j];
      return sum;
    }
  #+end_src

- Testing:
  #+begin_src bash :results output
    ls -l vlaSum.c
    gcc vlaSum.c -o vla
    echo 4 4 | ./vla
  #+end_src

  #+RESULTS:
  : -rw-rw-r-- 1 marcus marcus 591 Oct 15 10:22 vlaSum.c

- Alternate ways to prototype VLA parameter functions:
  #+begin_src C :results none
    int func1(int n, int a[n]); 
    int func2(int, int []);
    int func1(int n, int a[*]);
    int func1(int, int [*]);
  #+end_src

- The * is a wildcard character:
  #+begin_src bash
    ls *.c
  #+end_src

  #+RESULTS:
  | main.c     |
  | mainVLA.c  |
  | power2.c   |
  | power.c    |
  | repdigit.c |
  | reverse1.c |
  | reverse2.c |
  | reverse.c  |
  | stupid.c   |
  | vlaSum.c   |

- VLA parameters can also be expressions to be evaluated:
  #+begin_src C :results none
    int concat(int m, int n, int a[m], int b[n], int c[m+n]);
  #+end_src

* Compound Literals

- The term 'literal' always refers to unchangeable language elements,
  and the term 'compound' means that keywords are combined, like in
  =i++=, the compound operator representing =i = i + 1=.

- Using a /compound literal/, declaring and initializing an array can be
  avoided altogether:
  #+name: sum_array2
  #+begin_src C :main no
    // prototype declaration - VLA parameter
    int sum_array2(int k, int b[k]); 

    // main function
    int main()
    {
      printf("total = %d\n",
         sum_array2(5,(int[]){3,0,3,4,1})); // compound literal
      return 0;
    }

    // function definition
    int sum_array2(int n, int a[n])
    {
      int i, sum = 0;
      for (i=0;i<n;i++)
        sum += a[i];
      return sum;
    }

  #+end_src

  #+RESULTS: sum_array2
  : total = 11

- A compound literal resembles a cast =(int[])= applied to an
  initializer ={}=. It is also an /lvalue/, so the value of its elements
  can be changed. It can be made read-only by adding =const= before the
  type.

- An /lvalue/ (locator value) is an expression that points to a location
  in memory (that is it has an address):
  #+begin_src C :results none
    int x = 10; // x is an lvalue
    x = x + 1; // x is an lvalue on both sides of =
    int* p = &x;
  #+end_src

- An /rvalue/ (right-hand value) can only appear on the right of an
  assignment: It is a temporary value without a usable address.
  #+begin_src C :results none
    int y = 10 + 5; // `10 + 5` is an rvalue

    #define PI 3.14
    int x = PI; // PI is an rvalue, x is an lvalue

    //PI = 3.15;
  #+end_src
  
- A /cast/ is an operator that converts one type into another:
  #+begin_src C
    int i = 1; // integer
    float x = 3.14; // floating-point
    char c = 'a'; // character
    char *ic = "22"; // integer pointer

    printf("%f\n", (float)(i)); // cast int to float (widening)
    printf("%d\n", (int)(x)); // cast float to int (narrowing/truncates)
    printf("%c\n",c); // no cast
    printf("%d\n", (int)(c)); // cast char to int
    printf("%i\n", atoi(ic)); // cast string (char pointer) to int
  #+end_src

  #+RESULTS:
  : 1.000000
  : 3
  : a
  : 97
  : 22

- =atoi= is a function from the C Standard Library (=stdlib.h=) that
  converts a numeric string into an integer value. 
  #+begin_example C
    int atoi(const char *str)
  #+end_example
  The argument is a constant pointer to a string. We'll learn more
  about strings later.

- Are functions and operators the same thing, for example the
  functions =stdlib::atoi=, =stdio::printf= vs. the operators =sizeof= and
  =(int)=?
  #+begin_quote
  - An operator is compiled to a sequence of instructions.
  - When you call a function, it jumps to a separate bit of code.
  #+end_quote

