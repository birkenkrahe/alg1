#+TITLE: NOTEBOOK - DATA STRUCTURES
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: CSC 240 Data Structures Lyon College Fall 2024
#+STARTUP: overview hideblocks indent entitiespretty:
#+PROPERTY: header-args:C :main yes :includes <stdio.h> <stdlib.h> <string.h> :results output :exports both
* DONE Week 0 - Why You Are Here
#+attr_html: :width 500px:
[[../img/manga1.png]]

/Image: Why I like programming in C./

This week we met for our first session to get (re)acquainted with one
another, begin to learn about data structures, and understand what the
course is about.

** Why is the maximum number for a =char= type =127= and what does that mean?

It means that the computer can represent 127 characters, including
lower- and upper-case alphanumeric characters like ='a'= and ='A'=,
symbols like =+=, punctuation like =!=, and special characters like
newline, carriage return etc.

The maximum value is a constant stored in =limits.h=:
#+begin_src C :includes <float.h> <limits.h> <stdio.h>
  printf("%d\n", SCHAR_MAX);
#+end_src

#+RESULTS:
: 127

=127= is the maximum because the ASCII standard historically uses 7
bits - with 7 bits, each bit has two values so you can represent
2^7=128 different values, from 0 to 127.

To print the ASCII value of a character, print it with the =%d= format
specifier reserved for =int= (integer) values:
#+begin_src C :main yes :includes <stdio.h>
  printf("%d %d %d\n",'a','A','\\'); // the `\` must be escaped to be
  // printed as a character
#+end_src

#+RESULTS:
: 97 65 64

Later, an 8-th bit was added to extend the character set to 2^8 = 256
so that special symbols (like German umlauts =ü=, or the German =ß=) could
be represented.

* DONE Week 1 - What Data Structures Are About
#+attr_html: :width 500px:
[[../img/manga2.png]]

** Syllabus: About Using AI to write code for you or debug your code

I'm feeling quite strongly about this - [[https://github.com/birkenkrahe/org/blob/master/fall24/UsingAItoCode.org][here are my views]], which I
also attached to the syllabus. The short version: "Don't do it."

** Review questions (week 1)

1. What's the point of studying data structures?
   #+begin_quote
   To know the most efficient ways of storing, organizing and
   accessing data to solve a given computational problem.
   #+end_quote
2. What is a reason to use C in a course on data structures?
   #+begin_quote
   C is small and basic, and does not have many layers of abstractions
   (aka complex concepts) so that you can see and use data structures
   more directly through memory allocation and de-allocation.
   #+end_quote
3. Do you remember any of the differences between C, C++, and C#?
   #+begin_quote
   For example:
   - C allows you to manage your computer's memory directly, and was
     developed in the 1970s.
   - C++ is an Object-Oriented extension of C,and was developed in
     the 1980.
   - C# was developed by Microsoft for commercial applications, and
     was developed in the early 2000s.
   #+end_quote
4. What is the computing infrastructure that we use in this course?
   And what does each component deliver?
   #+begin_quote
   1. GitHub - Course materials repository
   2. Linux - Operating System
   3. Emacs - Editor to create, document, and run source code
   4. Canvas - Grades, assignments, tests
   #+end_quote
5. What does "computing on the edge" refer to and do you have an
   example?
   #+begin_quote
   "Edge computing" refers to processing data close to where it is
   generated, such as sensors, IoT devices, or machines, instead of
   sending the data to a distant data center for processing. Examples:
   Autonomous vehicles, programming in space, and augmented reality.
   #+end_quote
6. How should you study for this course?
   #+begin_quote
   1) Code every day, create small examples
   2) Review lecture notes and lectures on GitHub
   3) Seek help when you need it and don't wait
   #+end_quote
7. What are C's primitive (or built-in) data types?
   #+begin_quote
   - Integer (=int=)
   - Floating-point (=float= or =double=)
   - Character (=char=)
   - Void (=void=)
   #+end_quote
8. What does it mean that the maximum value for a =char= data type is =127=?
   #+begin_quote
   It means that the computer can represent 127 characters, including
   lower- and upper-case alphanumeric characters like ='a'= and ='A'=,
   symbols like =+=, punctuation like =!=, and special characters like
   newline, carriage return etc.

   =127= is the maximum because the ASCII standard historically uses 7
   bits - with 7 bits, each bit has two values so you can represent
   =2^7=128= different values, from 0 to 127.
   #+end_quote
9. What will this code print?
   #+begin_src C
     int i = 10000000000;
     printf("%d\n",i);
   #+end_src
   Explain the result!
   #+begin_src C
     #include <limits.h>
     printf("%d\n",INT_MAX); // Max integer: 2,147,483,647
     // All 31 bits besides the sign bit are '1' = 2^31 - 1
     // Any number above leads to overflow with ill results
   #+end_src
   In Python:
   #+begin_src python :results output :session *Python* :python python3 :exports both
     print(2**(31)-1); # 2,147,483,647
   #+end_src
10. When you see =%zu= in a C program, what do you expect?
    #+begin_src C
      const size_t INT = sizeof(int);
      printf("An integer is stored in %zu bytes.\n", INT);
      const size_t CHAR = sizeof(char);
      printf("A character is stored in %zu bytes.\n", CHAR);
    #+end_src

    #+RESULTS:
    : An integer is stored in 4 bytes.
    : A character is stored in 1 bytes.

** Orientation II: Course Content (cont'd) & Development Tools
#+attr_html: :width 600px:
#+CAPTION: Still Life With a Volume of Wither's Emblemes by Edward Collier (1696)
[[../img/tools.png]]

- [X] Derived data types
- [X] Data structures
- [X] Linux (with practice in Google Cloud Shell)
- [X] Emacs (with practice & assignment)
- [X] GitHub (with assignment)

** Assignments (Details in Canvas) by next week (Tuesday)

The first one of these is similar to our practice in class (in Google
Cloud Shell), while the second one involves many more steps and
requires more independence.

1. Solve any one of the 10 programming entry problems and submit your
   solution as an Emacs Org-mode file, including:
   1) A file header:
      #+begin_example
      #+TITLE: [give it a title]
      #+AUTHOR: [your name] (pledged)
      #+SUBTITLE: CSC 240 - Data Structures with C++ - Lyon College, Fall'24
      #+STARTUP: overview hideblocks indent
      #+PROPERTY: header-args:C :main yes :includes <stdio.h> :results output
      #+end_example
   2) An Org-mode headline with the program name, e.g. =* COOL PROGRAM=
   3) A short description of what the program does
   4) A code block
   5) Output as requested
   6) A short text reflecting on your experience - especially any
      difficulties you had during solving the exercise.

   To download the file from Google Cloud Shell, ="Open editor"= at the
   top, then open the explorer (="Home directory"=), right-click on the
   file name and =download= it to your PC.

   If your Emacs skills are rusty, you may need to complete [[https://tinyurl.com/emacs-tutor2][the Emacs
   tutorial]] (perhaps for the second time). See also the two videos
   that I made, linked at the start of the tutorial.

   The screenshot shows a sample file that is built exactly like the
   Org-mode file that you should submit (except with different code of
   course):
   #+attr_html: :width 600px:
   [[../img/sample.png]]

2. Complete the Hello World Project in GitHub and share a screenshot
   of your public GitHub repo with the hello-world repository.

   You find detailed step-wise instructions [[https://github.com/birkenkrahe/alg1/blob/main/org/0_overview.org#github-hello-world-exercise][here]] at the end of these
   lecture notes in GitHub.

** Review questions:

1. Examples for digital-to-analog, and for analog-to-digital
   conversion? Why is this relevant to data structures?
   #+begin_quote
   - Digital-to-analog: Player piano
   - Analog-to-digital: Voice recording
   - Relevance: Data structures are integral to the efficient storage,
     processing, compression, transmission, and conversion of digital
     data derived from analog signals. From basic arrays that store
     sample data to complex trees and graphs used in compression and
     error detection, they ensure that the digitization process is
     accurate, efficient, and reliable.
   #+end_quote
2. Explain this (full sentence): =const float PI = 3.14;=
   #+begin_quote
   Statement: Assign the value 3.14 to a constant floating-point
   variable =PI=
   #+end_quote
3. Explain this (full sentence): =#define PI 3.14=
   #+begin_quote
   Preprocessor directive: Replace the expression =PI= everywhere by the
   floating-point value =3.14=
   #+end_quote
4. What is Google Cloud Shell?
   #+begin_quote
   Google Cloud Shell is a command-line application that gives you
   access to a virtual Ubuntu 22.04 LTS Linux distribution.
   #+end_quote
5. What does the =gdb= debugger allow you to do?
   #+begin_quote
   The =gdb= program allows you to step through your program as it runs,
   and get information about variables and functions.
   #+end_quote
6. What do you need to do to use =gdb=?
   #+begin_quote
   You need to compile the source code with =gcc= and the =-g= flag, for
   example: =gcc main.c -o main -g= generates a debuggable executable
   =main=. Now you can start the debugger with =gdb main=.
   #+end_quote

** Introduction to Data Structures (Lecture) I (handout)

* DONE Week 2 - The Concert in the Egg Begins
#+attr_html: :width 600px:
#+caption: The Concert in the Egg ca. 1550 AD
[[../img/TheConcertInTheEgg.jpg]]

See on [[https://youtu.be/vfUAs7YbxlE?si=Rbw8egV_s_XQ6DGP][YouTube]]: The music in the painting, "Toutes les nuits que sans
vous je me couche" (Every night that I go to bed without you) by
Thomas Crecquillan (1549).

- [X] Setup: Linux server
- [X] Review: Intro to data structures
- [X] Array basics
- [ ] Quiz 2 is live (some missed Quiz 1)
- [ ] Graded: first two assignments
- [ ] Shared: sample solutions [[https://github.com/birkenkrahe/alg1/blob/main/org/alg1_entry_code_solutions.org][for C++]] and [[https://github.com/birkenkrahe/alg1/blob/main/org/alg1_entry_code_solutions_C.org][for C]]
- [ ] Review: Array basics (with practice)
- [ ] Array as data structure (code along lecture)

** Linux server has arrived

- You should have received your VM server address and password

- Start "Remote Desktop Protocol" on your (Windows) PC

- Enter the server name (e.g. =cslinux01.lyon.edu=) => =Connect=

- Login the =Xorg= session with username =firstname.lastname=, pw

- *Do not shut down or log out of the VM but only close the window*

- Currently access only from Lyon 104 but other subnets will be added.

- IT will give me admin access and set VMs to auto-boot soon.

** Review: Introduction to Data Structures I

1) Define "data structure"
   #+begin_quote
   A data structures is a way of organizing and storing data in a
   computer using a programming language.
   #+end_quote
2) Do different programming languages have different data structures?
   #+begin_quote
   Yes, different programming languages have different data
   structures. Some are built in, others have to be user-defined.
   #+end_quote
3) Name at least three different data structures!
   #+begin_quote
   1. Arrays, vectors, matrices
   2. Lists, Dictionaries
   3. Structures, classes
   4. Enumerations, strings
   5. Data frames, tables
   #+end_quote
4) Define "algorithm".
   #+begin_quote
   A step-by-step procedure to solve a problem with or without a
   computer, for example searching, sorting, printing.
   #+end_quote
5) What is the most common data structure in C, Python, R?
   #+begin_quote
   1. C: array
   2. Python: list
   3. R: vector
   #+end_quote

** Introduction to Data Structures (Lecture) II
** Array basics (review)
** On the Programming Assignments
#+attr_html: :width 400px:
#+caption: Portrait de femme au col d'hermine (Olga) - Picasso (1923)
[[../img/picasso.png]]

- This term, I am implementing a new rubric for grading your
  programming assignments. Check it out in the syllabus.

- The core message: complete the assignments on time and to the letter
  to get 100% of the points. Don't, and you lose points.

- For this first assignment, you can fix your mistakes and resubmit
  for full points. Only a handful completed all of the simple tasks.

- Make sure to read the full assignment and satisfy it to the
  letter. In this case, there was a complete sample solution available
  ([[https://github.com/birkenkrahe/alg1/blob/main/org/sample.org][GitHub or raw org]]), and all you had to do was imitate it.

** Review: Intro to data structures / array basics

We'll combine this review with some light coding. Useful also for the
2nd quiz where I've used some of these examples.

- Create an .org file
- Add at the top:
  #+begin_example
  #+property: header-args:C :main yes :includes <stdio.h> :results output
  #+end_example
- Run this line with C-c C-c
- Test it by creating a code block with: <s <TAB>
- In the code block write =printf("Hello, beautiful!");=
- Run this thing: C-c C-c


1. What distinguishes the choice of different data structures?
   #+begin_quote
   - Performance (speed, for example when searching through data)
   - Standardization (adherence to coding and data standards)
   - Portability (ability to run code anywhere)
   #+end_quote

2. You declare an array =A= in =main=. Where is this array stored in
   memory?
   #+begin_quote
   In the stack, because it is a local variable that disappears as
   soon as the =main= function is finished (when =return 0= is reached).
   #+end_quote
   Code example:
   #+begin_src C
     int main(void)
     {
       int A[5]; // array declaration
       return 0;
     }
   #+end_src

   #+RESULTS:

3. Which parts of the memory are read-only?
   #+begin_quote
   The memory sections for =const= "variables", and for machine code.
   #+end_quote
   Code example:
   #+begin_src C :results none
     const float pi = 3.1459; // stored in read-only memory
     pi++;  // pi = pi + 1 - generates error
   #+end_src

4. What is the memory "heap"?
   #+begin_quote
   The heap is memory reserved for "dynamically allocated" variables -
   variables whose memory is determined during run-time rather than
   compile-time. Such memory is allocated using the =malloc= function.
   #+end_quote
   Code example:
   #+begin_src C :includes <stdlib.h> :results none

     int *A = (int*)malloc(5 * sizeof(int)); // Allocate memory for 5 integers
     // You can now assign values to A[0] through A[4]
     free(A); // Free the allocated memory

   #+end_src

5. What are the stages of solving a computational problem?
   #+begin_quote
   1) Understanding the problem
   2) Identify solution (pseudocode)
   3) Identify data structures
   4) Implement solution
   5) Check solution (rinse & repeat if necessary)
   #+end_quote

6. Define "Abstract Data Type" and give at least one example
   #+begin_quote
   An abstract data type is a data structure together with basic
   operations (creation, deletion, insertion, extraction etc.)

   Examples:
   1) user-defined classes (=dog=), methods =doTricks=, =sleep=
   2) built-in arrays with element insertion, extraction
   3) linked lists with item insertion, removal
   #+end_quote

7. How would you declare and initialize an integer array of five
   elements with zero?
   #+begin_src C
     // Explicit initialization
     int A[5]; A[0]=A[1]=A[2]=A[3]=A[4]=0;
     // Implicit initialization
     int B[5] = {0};
     // Loop initialization
     int i; int C[5];
     for (i = 0; i < 5; i++)
       C[i] = 0;
     // Check results
     int j;
     for (j=0;j<5;j++) {
       printf("A[%d]: %d ", j, A[j]);
       printf("B[%d]: %d ", j, B[j]);
       printf("C[%d]: %d \n", j, C[j]);
      }
   #+end_src

   #+RESULTS:
   : A[0]: 0 B[0]: 0 C[0]: 0
   : A[1]: 0 B[1]: 0 C[1]: 0
   : A[2]: 0 B[2]: 0 C[2]: 0
   : A[3]: 0 B[3]: 0 C[3]: 0
   : A[4]: 0 B[4]: 0 C[4]: 0

8. What do you get when you print undeclared array elements?
   #+begin_quote
   You get 'undefined behavior'. Example: change the upper limit of
   the =Check results= loop from =5= to =10=.
   #+end_quote
   #+begin_src C
     // Explicit initialization
     int A[5]; A[0]=A[1]=A[2]=A[3]=A[4]=0;
     // Implicit initialization
     int B[5] = {0};
     // Loop initialization
     int i; int C[5];
     for (i = 0; i < 5; i++)
       C[i] = 0;
     // Check results
     int j;
     for (j=0;j<7;j++) {
       printf("A[%d]: %d ", j, A[j]);
       printf("B[%d]: %d ", j, B[j]);
       printf("C[%d]: %d \n", j, C[j]);
      }
   #+end_src

   #+RESULTS:
   : A[0]: 0 B[0]: 0 C[0]: 0
   : A[1]: 0 B[1]: 0 C[1]: 0
   : A[2]: 0 B[2]: 0 C[2]: 0
   : A[3]: 0 B[3]: 0 C[3]: 0
   : A[4]: 0 B[4]: 0 C[4]: 0
   : A[5]: 0 B[5]: 0 C[5]: 0
   : A[6]: -1412640919 B[6]: -1075053569 C[6]: -1533928960
9. When is the length of an array determined?
   #+begin_quote
   When the length of an array is determined depends on type of array:
   if it is a regular array, it is determined at compile time and
   cannot be changed when the program is run. If it is a
   variable-length array, or if it is a dynamically allocated array,
   its length is determined when the program is run ("at run-time").
   #+end_quote

10. When would it be useful to determine the length of an array when
    the program is running?
    #+begin_quote
    For example when the size of the data is user-driven: if a user
    specifies how many numbers they want to input, the array size must
    be determined based on their input.
    #+end_quote
    Code example for a variable-length based array:
    #+begin_src C :tangle main.c

      int n; // user-defined array length
      scanf("%d",&n); // get the length n from keyboard
      int A[n]; // Variable-Length Array
      int i;
      for(i=0;i<n;i++) {
        A[i]=i*i;  // assign value
        printf("%d ",A[i]); // print value
       }
    #+end_src

    #+RESULTS:

    Run tangled source code file:
    #+begin_src bash :results output
      gcc main.c -o main
      echo 10 | ./main
    #+end_src

    #+RESULTS:
    : 0 1 4 9 16 25 36 49 64 81

* DONE Week 3 - Array Basics
#+attr_html: :width 600px:
#+caption: M C Escher (geese)
[[../img/escher1.jpg]]

- [X] Quiz 2 to be completed (Fri 6 Sep)
- [X] Two new programming assignments (Tue 10 Sep)
- [X] If you're stumped - contact me

** Reviewing the Array Basics Review

1. If =A= is an array, what is =&A=?
   #+begin_quote
   If =A= is an array, then =&A= is the address of =A[0]=, the first element
   of =A=.
   #+end_quote
   #+begin_src C
     int A[2] = {100,200}; // declare & initialize array of two elements
     printf("%p\n%p", &A, &A[0]); // print address-of-A and address-of-A[0]
   #+end_src

   #+RESULTS:
   : 0x7ffcd3c67d20
   : 0x7ffcd3c67d20

2. How is the memory of an array organized?
   #+begin_quote
   The memory of an array is contiguous in memory, that is that the
   memory cells that hold array values are placed next to one another
   (this is the basis of *pointer arithmetic*). For a 2-dim array (aka
   matrix), the elements are stored in row-wise fashion.
   #+end_quote
   #+begin_src C
     int A[2][2] = {{1,2},{3,4}};
     printf("%p %p %p %p\n",       // print addresses as hexadecimals
            &A[0][0], &A[0][1],
            &A[1][0], &A[1][1]);
     printf("%d %d %d %d\n",       // print addresses as decimals
            &A[0][0], &A[0][1],
            &A[1][0], &A[1][1]);
   #+end_src

3. What's pointer arithmetic?
   #+begin_quote
   Arithmetic with memory positions. If =p= is an integer pointer, then
   =*(p + 1)= moves the pointer =p= by =1= integer (4 bytes), e.g. from
   memory position 100 to 104, because =sizeof(int)= is 4 bytes.
   #+end_quote

4. What's a variable-length array?
   #+begin_quote
   An array whose length is determined at run-time. It cannot be
   initialized in the source code, only declared, and its length comes
   from the user when the program runs.
   #+end_quote

5. What does =:main no= mean as a header argument?
   #+begin_quote
   It does not add =int main(void) { ... return 0; }= to the source
   code.
   #+end_quote

6. What does =:includes <limits.h>= mean as a header argument?
   #+begin_quote
   It adds =#include <limits.h>= to the C source code at the top.
   #+end_quote

7. In Linux, how can you find out how much memory is available?
   #+begin_src bash :results output :exports both
     free -h  # give me the free memory for humans
   #+end_src

   #+RESULTS:
   :                total        used        free      shared  buff/cache   available
   : Mem:           7.5Gi       2.3Gi       756Mi       617Mi       4.5Gi       4.3Gi
   : Swap:          2.0Gi          0B       2.0Gi

8. What is =bash=? What does it do?
   #+begin_quote
   =bash(1)= is a Linux shell program. It allows you to run other
   programs like =gcc= or =echo= or =free=. 'Run X on the shell/in the
   terminal' means 'let =bash= run it'. Some commands, like =cd=
   #+end_quote
   Example:
   #+begin_src bash :results output
     gcc --version
   #+end_src

9. What does "piping input into =main=" mean? Example?
   #+begin_quote
   It's a way of passing output from one program to another
   program. Example: in the command =echo 10 | ./main=, the number 10 is
   passed to a program called =main=. If =main= cannot use the number,
   it is simply ignored by =main=.
   #+end_quote

   An example that only works if you have a =main.c= program that takes
   the number =10= as a keyboard input:
   #+begin_src bash
     gcc main.c -o main
     echo 10 | ./main
   #+end_src

   #+RESULTS:
   : 0 1 4 9 16 25 36 49 64 81

10. What's wrong with this header argument?
    #+begin_example
    #+PROPERTY: header-args:C :main yes :includes <stdio.h> results: output
    #+end_example
    Answer: The =results= argument needs a colon in front of it:
    #+begin_example
  #+PROPERTY: header-args:C :main yes :includes <stdio.h> :results output
  #+end_example


** Arrays as data structures (handout)
#+attr_html: :width 600px:
#+caption: M C Escher (birds)
[[../img/escher.jpg]]

* DONE Week 4 - VLAs, Macros, Arrays
#+attr_html: :width 300px:
#+caption: M C Escher (crystal ball)
[[../img/escher.gif]]

- [X] Emacs tip of the day: creating more than one window (C-x 5 2)
- [X] Video + solution "Sample Array Operations" assignment
- [X] 2 more programming assignments for arrays
- [X] Continue with the "reverse array elements" program ([[file:2_arrays_codealong.org][code along]])
- [X] Quiz 3 is live
- [X] Learn different ways to compile and run a source code file
- [X] Learn Variable-Length Arrays (VLAs) for dynamic allocation
- [X] Learn parameter macros

** Programming assignments and sample solutions

Please let me know how to make these videos better (if you have an
idea, and if you don't, just give me some general feedback).

Use my sample solution to create your own solution if you like and
submit it late for at most 50% of the points, but make sure that you
don't copy and paste but write all code by hand and understand it.

* DONE Week 5 - Diligence and Debugging
#+attr_html: :width 600px:
[[../img/coach.png]]

- [X] Assignment 3 + 4 review
- [X] Assignment 5 preview
- [X] Review (and quiz 4 preview)
- [X] Using the =gdb= debugger
- [X] Three simple practice exercises
- [ ] Functions & Recursion

** Assignment 3 review - A sermon, code, questions, and some answers
#+attr_html: :width 600px:
[[../img/submission3.png]]

For this assignment, I will waive the 50% rule for late
submissions. If you submit a correct version within 1-2 weeks you can
still get full points.

The complete problem & sample solution file is on GitHub:
[[https://tinyurl.com/simple-array-operations-org][tinyurl.com/simple-array-operations-org]] - the video is on YouTube:
http://www.youtube.com/@LiterateProgramming

*** A look at a sad,sad gradebook (snapshot, Sat 14-Sep)
#+attr_html: :height 500px:
[[../img/grades.png]]

**** Data science people: Plot it using R!

#+begin_src R :file ../img/grades.png :session *R* :results file graphics output :exports both
  grades <- c(0.,7.62,30.16,30.16,32.59,45.24,45.56,53.02,
              59.26,62.22,63.17,65.4,76.19,98.33,98.41,98.89)
  hist(grades, xlab="Grades [%]", main="Total grades CSC 240 (14-Sep-2024)");
  abline(v=mean(grades),col="red",lwd=2)
#+end_src

#+RESULTS:
[[file:../img/grades.png]]


*** Did anyone do well?
#+begin_quote
- Only one student (Austin) received a grade for a complete & correct
  submission.
- Everyone else either did not submit (0 points) or received feedback
  and was asked to resubmit within 1-2 weeks for full points.
- If you did not submit (and have no accommodations), you get at most
  50% (so it's worth submitting even if you have very little).
- If you have accommodations, you've got an extra week (you might have
  to remind me).
#+end_quote

*** Why can't we just submit the code?
#+begin_quote
You know the answer: I want you to engage not just with solving the
problem, which is often very simple, but with the infrastructure, with
the class material, and with your own problem solving abilities (or
lack thereof). The raw code is something AI can produce already.

Another reason: Your code is buggy. Do you really mean for me to run
your code, fix your errors, etc. Would that irritate or interest you
if you were me? I believe I can spend my time a lot more useful than
that. Time-wise, checking a submission & fixing & giving feedback
takes no less than 15 minutes, which would be four hours per
programming assignment for this class only, or 8 hours for two weekly
assignment = one whole work day.
#+end_quote


*** What areas of improvement were there this time?

1) Submission contains only the code and some accidental output.

2) The test case, which must be reproduced to the letter, is missing.

3) The reflection comes at the end and appears perfunctory.

4) The solution path is missing (usually at the start).

5) The document contains no structural elements (like headlines).

6) The code shows no indentation, and is hard to read (use C-M-\)

7) The =main= and =include= commands are already in the header but they
   are repeated.

8) The program is missing a header - not explicitly asked for but
   important: do you really want to have to read the code/comments to
   find out what this program does?

9) The shell code block is missing the =:results output= header.

10) Using different loop variables though there is only one type of
    loop (over the elements of the array).

11) The Org-mode file meta data at the top of the file are
    malformatted: for example `#+title` is just text - the keyword is
    =#+title:=, and `#+` on its own achieves nothing.

12) The documentation is not to be hidden after C comments `//` or
    `#+` or in a separate text file but in (ideally ahead of) the
    code.

All of this is perfectly clear in any of my lecture of practice files.


*** What happens if I always submit correct code but don't respect the instructions?
#+begin_quote
You know the answer: If I don't get a resubmission, you will be judged
according to the rubric. Data structures is not an introductory course
for people who want to see if programming is for them. It's a serious,
difficult collection of topics that you need to master on your way
towards becoming a computer or data science *professional*.
#+end_quote

** Which rubric?
#+attr_html: :width 600px:
[[../img/rubric.png]]


*** Is there no other way?
#+begin_quote
Not at Lyon. You can probably create a brilliant career for yourself
studying hard and with great discipline, on your own, with mostly free
resources, spending time rather than money - I've done it myself, but
currently you're on a different path, and why not make the best of it?
#+end_quote


*** What if I just didn't have enough time but wanted to submit what I had?
#+begin_quote
That's perfectly fine if you respond to my feedback within a
reasonable amount of time (1-2 weeks) and resubmit with fixes. I am
easy in that I will still give you full points for applying yourself -
but just trying is no longer enough.
#+end_quote


*** Why do students not respect instructions for submission?

- This is what ChatGPT has to say what the resons could be why some,
  not all students systematically ignore my instructions:
  #+begin_quote

There are several potential reasons why students might systematically
ignore submission instructions:

1. *Lack of Clarity or Understanding*: Students may not fully understand
   the instructions due to unclear language or insufficient
   examples. If instructions are ambiguous or overly complex, students
   may misinterpret them.

2. *Overwhelming Details*: When submission instructions contain too many
   steps or technical details, students may feel overwhelmed and skip
   parts they consider less important.

3. *Lack of Emphasis on Consequences*: If students don't perceive clear
   consequences for failing to follow submission guidelines, they may
   not see the value in adhering to them strictly.

4. *Time Management Issues*: In a rush to meet deadlines, students may
   prioritize completing the task itself over ensuring the submission
   follows the format exactly.

5. *Lack of Familiarity with Tools*: Students unfamiliar with tools like
   Org-mode or Emacs may struggle with those aspects of the submission
   process, especially if they haven’t had enough practice or
   guidance.

6. *Technical Difficulties*: Issues such as trouble with software setup,
   tangling files, or file submission platforms might lead students to
   avoid following the specific instructions.

7. *Perception of Redundancy*: Students may see submission instructions
   as bureaucratic or unnecessary if they believe the core task
   (solving the problem) is more important than the format in which
   it's submitted.

8. *Disregard for Attention to Detail*: Some students may not yet
   appreciate the importance of attention to detail, particularly in
   fields like computer science, where strict adherence to
   instructions is often essential.

9. *Inadequate Feedback*: If students previously ignored submission
   instructions without receiving specific feedback about that, they
   may not realize it's a problem.

10. *Language Barriers*: For students for whom the language of
    instruction is not their first language, submission instructions
    might be harder to grasp, particularly if there’s jargon or
    technical language involved.

Understanding these reasons can help instructors adjust their
approach—whether by simplifying instructions, providing more training
on tools, or emphasizing the importance of submission formatting.
  #+end_quote

Short summary:

| ISSUE                  | ACTION                                                  |
|------------------------+---------------------------------------------------------|
| *Lack of clarity*        | Ask! Let me know if anything is unclear                 |
| *Overwhelming detail*    | Translate instructions for yourself                     |
| *Lack of consequences*   | You must resubmit until you have fixed your submission  |
| *Time management*        | Start early, program a little daily, ask for help       |
| *Unfamiliar tools*       | Go through the Emacs tutorial. Code along my videos.    |
| *Technical issues*       | Practice more and/or install tools on your laptop       |
| *Format unimportant*     | Just believe me when I say it's important               |
| *No attention to detail* | Switch off distractions and focus on the details        |
| *Inadequate feedback*    | You should have had message(s) from me about this       |
| *Language barrier*       | Again: ask me, or ask other students, and learn         |

Short response:

1. Suck it up!
2. It's for your own good!
3. No pain, no gain!

*** What else will you do to help us?
#+begin_quote
- I will make a video of my sample solution, which you can use to
  improve your game, identify your mistakes, and help me make better
  videos.

- I will continue to give you detailed feedback so that you can fix
  your errors. I usually "reassign" the assignment without giving 0
  points. In this way your grade does not suffer but if I don't get a
  resubmission within 1-2 weeks, I will give you partial points (50%).

- Talk to me if you're unhappy about this and we can try to find a
  solution that satisfies both my and your needs!
#+end_quote
*** Any questions?

You must learn to ask questions, ideally in the class: most problems
that I've encountered are shared among students. Help others and they
will help you!

** Assignment 4 review
#+attr_html: :width 600px:
[[../img/submission3.png]]

For this assignment, I will waive the 50% rule for late
submissions. If you submit a correct version within 1-2 weeks you can
still get full points.

The complete problem & sample solution file is on GitHub:
[[https://tinyurl.com/array-temperature-analysis-org][tinyurl.com/array-temperature-analysis-org]] - a short video (v1 only)
is on YouTube: http://www.youtube.com/@LiterateProgramming

Nothing new - almost everybody made the same mistakes (3/9 submissions
got full points). I noticed that many of you seem to submit 5 minutes
before the deadline. That's not leaving yourself enough time for
something that requires a lot of diligence.

** Review: VLA, Macros & Quiz 4 Preview

1. How would you compute the course average using VLAs in C! Here are
   the grades for you to copy: [[https://tinyurl.com/grades-fall24][tinyurl.com/grades-fall24]]

   #+begin_src bash :results output :exports both
     echo 7.62 30.16 30.16 32.59 45.24 45.56 53.02 59.26\
          62.22 63.17 65.4 76.19 98.33 98.41 98.89 > ../data/grades
     cat ../data/grades
   #+end_src

   #+RESULTS:
   : 7.62 30.16 30.16 32.59 45.24 45.56 53.02 59.26 62.22 63.17 65.4 76.19 98.33 98.41 98.89

   This is really easy in R:
   #+begin_src R :session *R* :results output :exports both
     df <- read.csv("https://tinyurl.com/grades-fall24",sep=" ",header=FALSE)
     df
     mean(read.csv("https://tinyurl.com/grades-fall24",sep=" ",header=FALSE))
   #+end_src

   #+name: grades
   #+begin_src C :tangle main.c
     int i, n;
     float grades[n], sum=0.;
     scanf("%d",&n);
     for (int i=0;i<n;i++) {
       scanf("%f",&grades[i]);
       printf("%g ",grades[i]);
       sum+=grades[i];
      }
     printf("\nAverage = %g\n",sum/n);
   #+end_src

   #+RESULTS: grades
   : 7.63359e-33 4.56655e-41 7.63176e-33 4.56655e-41 1.26117e-44 1.4013e-45 7.6324e-33 4.56655e-41 0 0 0 4.56655e-41 0 0 0 4.59121e-41 -nan 0 7.64256e-33 4.56655e-41 7.63921e-33 4.56655e-41 7.81411e-33 4.56655e-41 7.64256e-33 4.56655e-41 7.63377e-33 4.56655e-41 7.81625e-33 4.56655e-41 7.63752e-33 4.56655e-41 7.63979e-33 4.56655e-41 0 0 7.63856e-33 4.56655e-41 1.82169e-44 0 7.63176e-33 4.56655e-41 7.51747e-33 4.56655e-41 3.31953e+15 3.06296e-41 3.32257e+15 3.06296e-41 7.8121e-33 4.56655e-41 7.69459e-33 4.56655e-41 1.4013e-45 0 0 0 7.63921e-33 4.56655e-41 7.71997e-33 4.56655e-41 1.73856e-30 4.59121e-41 1.73861e-30 4.59121e-41 1.4013e-45 0 1.73863e-30 4.59121e-41 3.31953e+15 3.06296e-41 7.70328e-33 4.56655e-41 0 0 3.32257e+15 3.06296e-41 1.73864e-30 4.59121e-41 0 0 7.8156e-33 4.56655e-41 7.52299e-33 4.56655e-41 7.65562e-33 4.56655e-41 0 0 7.81527e-33 4.56655e-41 7.81657e-33 4.56655e-41 1.4013e-45 4.59121e-41 1.13001e-41 9.18341e-41 1.73844e-30 4.59121e-41 -0.0113305 2.36539e-42 0 0 0 0 0 0 1.82357e-30 4.59121e-41 0 4.48416e-44 0 0 0 0 1.25556e-42 1.25556e-42 1.4013e-45 0 1.02539e-36 1.4013e-45 0 0 1.25556e-42 1.25556e-42 1.25556e-42 1.25556e-42 1.25556e-42 1.25556e-42 0 0 0 0 0 0 0 0 0 0 0 0 3.57331e-43 3.57331e-43 0 0 1.59329e-10 1.59329e-10 1.59329e-10 1.59329e-10 4.87652e-42 0 0 0 1.34525e-43 0 0 0 1.4013e-45 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4.59177e-41 0 8.26519e-40 0 1.14794e-41 0 1.10203e-39 0 4.59177e-41 0 8.26519e-40 0 1.12104e-44 0 8.96831e-44 0 5.60519e-45 0 8.96831e-44 0 1.68156e-44 0 2.8026e-45 0 1.96182e-44 -0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7.73849e-33 4.56655e-41 1.82169e-44 0 1.4013e-45 0 1.4013e-45 0 1.4013e-45 0 3.31834e+15 3.06296e-41 7.73235e-33 4.56655e-41 2.84744e-42
   : Average = -nan

   #+begin_src bash :results output :exports both
     gcc main.c -o main && echo "16 0. 7.62 30.16 30.16 32.59 45.24 45.56
     53.02 59.26 62.22 63.17 65.4 76.19 98.33 98.41 98.89" | ./main
   #+end_src

   #+RESULTS:
   : 0 7.62 30.16 30.16 32.59 45.24 45.56 53.02 59.26 62.22 63.17 65.4 76.19 98.33 98.41 98.89
   : Average = 54.1387

   You can also get this from the URL with =wget=:
   #+begin_src bash :results output :exports both
     echo 16 > grades2
     wget -q -O - https://tinyurl.com/grades-fall24 >> grades2
     cat grades2
   #+end_src

   #+RESULTS:
   : 16
   : 7.62 30.16 30.16 32.59 45.24 45.56 53.02 59.26 62.22 63.17 65.4 76.19 98.33 98.41 98.89

   Now you can redirect the file =grades2= into the executable =./main=
   #+begin_src bash :results output :exports both
     gcc main.c -o main && ./main < grades2
   #+end_src

   #+RESULTS:
   : 7.62 30.16 30.16 32.59 45.24 45.56 53.02 59.26 62.22 63.17 65.4 76.19 98.33 98.41 98.89 4.55926e-41
   : Average = 54.1387

   Incidentally, you can do this also in the Org-mode code block using
   the header argument =:cmdline < grades2=, and then you don't have to
   tangle the source code:
   #+begin_src C :cmdline < grades2
     int i, n;
     float grades[n], sum=0.;
     scanf("%d",&n);
     for (int i=0;i<n;i++) {
       scanf("%f",&grades[i]);
       printf("%g ",grades[i]);
       sum+=grades[i];
      }
     printf("\nAverage = %g\n",sum/n);
   #+end_src

   #+RESULTS:
   : 7.62 30.16 30.16 32.59 45.24 45.56 53.02 59.26 62.22 63.17 65.4 76.19 98.33 98.41 98.89 4.59149e-41
   : Average = 54.1387

   In future assignments with user input, you can pick your poison -
   =bash= code block input with pipe command, or =cmdline= file input.

2. What constraints are place on VLA declaration?

   #+begin_quote
   Variable-length arrays get their length at run-time so they cannot
   be initialized at compile-time.
   #+end_quote

3. In an array =a[10]=, what is the difference between =sizeof(a[0])= and
   =sizeof(a[10])=, and how would you show this?

   #+begin_src C
     int a[10]={0};
     printf("Size of a[0] = %zu\nSize of a[10] = %zu\n",
            sizeof(a[0]),       sizeof(a[10]));
   #+end_src

   #+RESULTS:
   : Size of a[0] = 4
   : Size of a[10] = 4

4. How would you convert the following selection statement into a
   parameter macro?

   #+begin_example C
   if (x < y)
      x
   else
      y
   #+end_example
   #+begin_src C
     #define MIN(x,y) ((x)<(y)?(x):(y))

     int x = 100, y = 200;
     printf("min(%d,%d) = %d", x,y,MIN(x,y));
   #+end_src

   #+RESULTS:
   : min(100,200) = 100

5. What if you were tired of writing =sizeof(a)/sizeof(a[10])= - could
   you write it as a parameter macro?

   #+begin_src C
     #define LEN(a) sizeof(a)/sizeof(a[10])

     int a[10];
     printf("Length of array: %zu\n", LEN(a));
   #+end_src

   #+RESULTS:
   : Length of array: 10

6. What if you don't want to use =0= and =1= for =false= and =true=?
   #+begin_quote
   If you want to use =true= and =false=, =#include <stdbool.h>=. Now you
   can declare a =bool= data type.
   #+end_quote

   Example:
   #+begin_src C
     #include <stdbool.h>

     bool beauty = true;
     bool ugly = false;

     printf("If beautiful equations are %s,\nthen ugly equations are %s.\n",
            beauty ? "true" : "false",
            ugly   ? "true" : "false");
   #+end_src

   #+RESULTS:
   : If beautiful equations are true,
   : then ugly equations are false.

7. When using AI to help you solve an assignment, what must you do?
   #+begin_quote
   When using AI assistance in any way, I suggest you mention in your
   solution that, and how, you made use of it (and if it helped you).
   #+end_quote

** Using the C debugger =gdb=
#+attr_html: :width 400px:
[[../img/pythontutor.png]]

- Get the raw file from tinyurl.com/repdigit-c on the shell (=M-x shell=
  #+begin_src bash :results output :exports both
    wget -O repdigit.c tinyurl.com/repdigit-c
    ls -l repdigit.c
  #+end_src

  #+RESULTS:
  : -rw-rw-r-- 1 marcus marcus 885 Sep 19 09:45 repdigit.c

- Open the source code file with =M-x global-linum-mode=

- Split the screen into shell and source code file:
  #+attr_html: :width 500px:
  [[../img/repdigit2.png]]

- Compile the file with the =-g= flag:
  #+begin_src bash :results output :exports both
    gcc repdigit.c -o rep -g
    ls -l rep
  #+end_src

  #+RESULTS:
  : -rwxrwxr-x 1 marcus marcus 17384 Sep 19 09:45 rep

- Run it through the =gdb= debugger with: =gdb rep=

- Commands to try in =gdb=:
  #+begin_example
  (gdb) run
  (gdb) help
  (gdb) info locals
  (gdb) break 23
  (gdb) step
  (gdb) print n
  (gdb) continue
  #+end_example

- Compare with =pythontutor.com=:
  1) Choose =C=
  2) Paste =repdigit.c= into editor
  3) Visualize execution
  4) Step through program with =Next=

** Three practice exercises (popquiz)
#+attr_html: :width 400px:
[[../img/practice.png]]

Solve these exercise in class and upload your results for bonus
points to Canvas:

- Boolean array declaration
- Array of Fibonacci numbers
- Initialize and print matrix

  Solutions to the exercises are in GitHub in the PDF directory.

* DONE Week 6 - Function Prototypes and Parameters
#+attr_html: :width 600px:
[[../img/four-monks-by-rinaldi-9696.jpg]]

/Image: Four monks by Claudio Rinaldi (1852-1909). (Dorotheum, Munich)/

Topics:
- [X] Warm-up program
- [X] Function prototypes [assignment 6]
- [X] Arguments vs. Parameters
- [X] Passing arrays (by reference [assignment 7]
- [ ] Compound literals
- [ ] Return and exit
- [ ] Recursion
- [ ] Quicksort algorithm

Every topic will generate 1 home programming assignment!

Only 2 assignments per week will be mandatory, the others: bonus!
- Turn warmup program into program with 3 functions
- Write function headers for functions seen in class

** Results: Quiz 3 + 4
#+attr_html: :width 600px:
[[../img/quiz3.png]]

Quiz 3

#+attr_html: :width 600px:
[[../img/quiz4.png]]

Quiz 4

- Good: Almost everybody turns in the quiz on time!
- Good: Consistent performance (one outlier only)
- OK: Average time 12-17 minutes (one extreme outlier)

** Results: Programming assignment
#+attr_html: :width 600px:
#+Caption: Detail from Raphael, The School of Athens (1511)
[[../img/perplexity.jpg]]

- No update for the last two assignments yet: *If you haven't
  resubmitted yet and are at a loss: contact me!* (You got till Friday)

- Some have mended their submission ways as discussed

- Some have not (why? Time? Reassignment = rehabilitation)

- More than 40% have not submitted at all (why? Time?)

- *Submit what you have before the deadline to get a 2nd chance*!

- If you like watch my 30 minute solution video (new style) - 5 views

** Function prototypes, arguments vs. parameters
#+attr_html: :width 700px:
[[../img/basic.png]]

[[https://chat.google.com/room/AAAAcFTK-VI/4EFCXSCUCCY/4EFCXSCUCCY?cls=10][*YOU MUST ADDRESS YOUR C BASICS WEAKNESSES NOW*]]

("... or forever hold your peace").

** Review (Function prototypes)

1. What's the purpose of a function prototype?
   #+begin_quote
   The purpose of a function prototype is to declare a function to the
   compiler by declaring the header (return type, name, parameters)
   without the implementation (the function body).
   #+end_quote

2. What's a function definition?
   #+begin_quote
   A function definition is a fully implemented function, including a
   header (return type, name, parameters), and a body (code to be
   executed when the function is called).
   #+end_quote

3. Where can you define a function in a C program?
   #+begin_quote
   - If you declared its prototype before =main=, the function can be
     defined anywhere.
   - If you did not declare a prototype, the function must be defined
     before or inside the =main= function.
   #+end_quote

4. The function is defined as =void f(int a, int b)=. Can the function
   prototype be declared like this?
   #+begin_src C
     void f(int, int);
   #+end_src

   #+begin_quote
   Yes. The prototype declaration does not need to contain parameters,
   only parameter data types.
   #+end_quote

5. Can a =void= function have a =return= command?
   #+begin_quote
   No. If it's a =void= function that means that it returns nothing. A
   =return 0;= command will compile but generate a warning.
   #+end_quote

   #+begin_src C :return none
     void hello(void)
     {
       printf("hello");
       return 0;
     }
   #+end_src

   #+RESULTS:

6. How should you call a function with a =void= parameter list?
   #+begin_quote
   If it has a =void= or empty =()= parameter list, it is called without
   arguments.
   #+end_quote

   #+begin_src C :main no
     // function definition
     void hello(void)
     {
       printf("hello");
     }
     // main program
     int main (void)
     {
       hello();
       return 0;
     }
   #+end_src

   #+RESULTS:
   : hello

7. Will the following code compile?

   #+begin_src C :main no :return none
     // prototype
     void f(int a);
     // main program
     int main (void)
     {
       float b;
       f(b);
       return 0;
     }
     // function definition
     void f(int a) {}
   #+end_src

8. What does "passing arguments by value" mean?
   #+begin_quote
   "Passing arguments by value" means that arguments after a function
   call are copied so that the original arguments are not changed.
   #+end_quote

9. What do you need to change when your code block has a =main=?
   #+begin_quote
   You need to set the header argument =:main= to the value =no=.
   #+end_quote

10. How can you "break" a function without violating Syntax rules?
    #+begin_quote
    - Mismatched =return= type between declaration and =return= argument
    - Mismatched =return= type between declaration and definition
    - Missing =return= command though a =return= type is declared
    - Argument mismatch
    - Modifying =const= parameters inside the function
    #+end_quote

* DONE Week 7 - Pass-by-value, pass-by-reference, pointers
#+attr_html: :width 400px:
[[../img/podcasters.png]]

Announcements:
- [X] *New!* 12-minute podcast on "C Arrays" (see [[https://chat.google.com/room/AAAAcFTK-VI/_Kwvf0bBml8/_Kwvf0bBml8?cls=10][chat]]) - let me know
  what you think! I've already turned "C Functions" into a podcast -
  fun review!

- [X] *New!* 6-minutes podcast on "C functions (see [[https://chat.google.com/room/AAAAcFTK-VI/UifqRr1crOI/UifqRr1crOI?cls=10][chat]]) - let me know
  what you think! (Based on a 46p. script)

- [X] *Poll!* Who has got *WSL* (Windows Subsystem Linux) on his Windows
  PC? Enrol my help to do this (same environment as in class)!

Next topics:
- [X] Passing by reference
- [X] Multi-dimensional arrays
- [ ] Compound literals
- [ ] Return and exit
- [ ] Recursion
- [ ] Quicksort algorithm

** Programming assignments are getting better!

- R code chunk (if you like how this looks, get into data science!)
  #+begin_src R :file ../img/gradesDensity.png :session *R* :results file graphics output :exports both
    grades1 <- c(0.,7.62,30.16,30.16,32.59,45.24,45.56,53.02,
                 59.26,62.22,63.17,65.4,76.19,98.33,98.41,98.89)
    grades2 <- c(20.56,35.42,42.78,48.75,52.78,57.5,69.86,70.42,
                 75.,76.11,81.53,83.19,86.39,91.25,98.47,104.29)

    ## Get the common x and y limits
    xlim <- range(c(grades1, grades2))
    ylim <- range(c(density(grades1)$y, density(grades2)$y))

    ## First plot with specified xlim and ylim
    plot(density(grades1), lwd=2, col="red",
         xlab="", ylab="", main="", xlim=xlim, ylim=ylim, yaxt="n")

    ## Overlay the second plot with the same xlim and ylim
    par(new=TRUE)
    plot(density(grades2), lwd=2, col="blue",
         xlab="Grades [%]", main="Total grades CSC 240",
         xlim=xlim, ylim=ylim, yaxt="n")

    ## Add mean lines for grades1
    abline(v=mean(grades1), col="red", lwd=2)

    ## Add mean lines for grades2
    abline(v=mean(grades2), col="blue", lwd=2)

    ## add a legend
    legend("topleft", legend=c("14-Sep", "30-Sep"),
           col=c("red", "blue"), lwd=2)
  #+end_src

  #+RESULTS:
  [[file:../img/gradesDensity.png]]

- Many of you still have not submitted assignment 2 (= *low hanging fruit*).

- Some of you have not submitted the last 2-3 assignments (*see me!!!*).

- Some of you are still struggling with *sticking to instructions*.

- From now on I will grade what you submit *as I see it*.

- Late submissions will get *at most 50%* of the available points.

- *Late submissions for mid-term must be submitted by 12 pm on 8 Oct*

- You can always send me your solution for comment before submitting.

- Use "Hurkle-Durkle-Day" weekend to *improve your grade & skills*.

- Extended deadline for assignments 6 + 7 is *Mon 7 October (11:59pm)*

- I will video my sample solutions & create a podcast on them.

** Review (Passing by value, passing arrays)

1. What should be included in a function documentation header?
   #+begin_quote
   Name, purpose, return type, parameters, edge cases/use.
   #+end_quote
   Example:
   #+begin_example C
   // Name: power
   // Purpose: Compute power of an integer
   // Returns: integer = n-th power of integer x
   // Params: integer (base) x, integer (power) n
   #+end_example

2. What does "passing an array by reference" mean?
   #+begin_quote
   Array arguments are inherently passed by reference.

   Instead of passing a copy of the array, a pointer to the first
   element of the array is passed to the function.
   #+end_quote

3. Do changes made to the array elements inside the function affect
   the original array in the calling function?
   #+begin_quote
   Yes, any changes made to the array elements inside the function
   affect the original array:

   1. When an array is passed to a function, it "decays" into a
      pointer to its first element - only the address of that element
      is received.
   2. Modifications to the array elements change the original array,
      since no copy was made and the pointer operates on the original.
   #+end_quote

4. How does the function call to pass an array =a[10]= look like?
   #+begin_example C
     int a[10]; // array declaration
     f(a,10);  // function call
   #+end_example

5. Show this with a short example including =main= and a function!
   1) Prototye =void= function =foo= with array parameter
   2) In =main=: Define 1-dimensional array =bar[2]= and init to ={0}=
   3) In =main=: Print array elements
   4) In =main=: Call function on array
   5) In (=void=) function: change elements in array to ={1}=
   6) In main: Print array elements

   Solution:
   #+begin_src C
     void foo(int [], int); // 1

     int main(void)
     {
       int bar[2]={0}; // 2
       printf("%d %d\n",bar[0],bar[1]); // 3
       foo(bar,2); // 4
       printf("%d %d\n",bar[0],bar[1]); // 5
       return 0;
     }

     void foo(int a[], int n)
     {
       a[0] = a[1] = 1;  // 4
     }
   #+end_src

   #+RESULTS:
   : 0 0
   : 1 1

** Review (Passing by value vs. reference)

1. In the =decompose= program, we split a =float= into an =int= and another
   =float= - which format specifiers are used to print these?
   #+begin_src C
     float x = 3.14159;
     float frac_part;
     int int_part;

     // split x
     int_part = (int) x;
     frac_part = x - int_part;

     // print results
     printf("x = %g, i: %d, d: %g\n", x, int_part, frac_part);
   #+end_src

   #+RESULTS:
   : x = 3.14159, i: 3, d: 0.14159

2. What if we wanted to split a =double= floating-point instead?
   #+begin_src C
     double x = 3.141592653589793;
     double frac_part;
     long int_part;

     // split x
     int_part = (long) x;
     frac_part = x - int_part;

     // print results
     printf("x = %.15f, i: %ld, d: %.15f\n", x, int_part, frac_part);
   #+end_src

   #+RESULTS:
   : x = 3.141592653589793, i: 3, d: 0.141592653589793

3. If =*p= is a pointer to =&i=, the address of the =int= variable =i=, what
   are the following variables, and are they even allowed?
   #+begin_example C
    &(*p)
    *(&i)
    *(&(*p))
    &(*(&i))
   #+end_example

   #+begin_src C
     int  i = 100; // integer
     int* p = &i; // pointer to integer

     // integer, address-of integer, pointer
     printf("i        = %d, &i       = %d, p = %d\n", i, &i, p);

     // dereferenced pointer, address-of dereferenced pointer
     printf("*p       = %d, &(*p)    = %d\n", *p, &(*p));

     // deferenced reference/address-of integer (value)
     printf("*(&i)    = %d\n", *(&i));

     // dereferenced address-of dereferenced pointer (value),
     // address-of dereferenced address-of integer (address
     printf("*(&(*p)) = %d, &(*(&i)) = %d\n",*(&(*p)),&(*(&i)));
   #+end_src

   #+RESULTS:
   : i        = 100, &i       = 1277825468, p = 1277825468
   : *p       = 100, &(*p)    = 1277825468
   : *(&i)    = 100
   : *(&(*p)) = 100, &(*(&i)) = 1277825468

4. What could =**p= be if =*p= is a pointer to =&i=? Is that allowed?
   #+begin_quote
   =*(*p)= is a pointer to a pointer (aka "double pointer"): it contains
   the memory address of the pointer (which in turn points at the
   memory address of =i)=.

   Double pointers give you control over both =p= and =i= at different
   levels.
   #+end_quote

5. Change where =p= points to, and the value of =i= using double pointers:
   1) Start with =int i = 100; int* p = &i;=
   2) Define pointer =pp= that points to =p=
   3) Print =*p=    = *(&i) = i
   4) Print =*pp=   = *(&p) = *(&(&i)) = &i
   5) Print =**pp=  = *(*pp)= *(&i) = i
   6) Add 100 to =**p= and print it
   7) Define =int j = 300=
   8) Redirect =pp= to =j=: **pp = *(&p) = p = &j
   9) Print =*p= = *(&j) = j

   #+begin_src C
     int i = 100;
     int* p = &i; // p points to i (address)
     int** pp = &p; // pp points to p (address)

     printf("i    = %d\n",i); // integer value
     printf("p    = %d\n",p); // pointer to i
     printf("*p   = %d\n",*p); // dereference p = value of i (value)
     printf("*pp  = %d\n",*pp); // dereference pp = value of p (address)
     printf("**pp = %d\n",**pp); // dereference *pp = value of *p (value) = i

   #+end_src

   #+RESULTS:
   : i    = 100
   : p    = 162926260
   : *p   = 100
   : *pp  = 162926260
   : **pp = 100

   - Here is a diagram that summarizes the relationships:
     #+attr_html: :width 600px:
     [[../img/double_pointer.png]]

6. Coding challenge:
   1. [[pass-by-value]] generates the output: 0 0
   2. Copy the following code in [[pass-by-value]].
   3. Copy the code block to a new block [[pass-by-reference]].
   4. Modify the function to pass-by-reference:
      - The function call passes a reference (address)
      - The function parameter becomes a pointer (pointing to ~n~)
      - The function body uses pointers
   5. [[pass-by-reference]] generates the output: 0 1

   Increment a number with a pass-by-value function:
   #+name: pass-by-value
   #+begin_src C :main no
     void increment(int num)  // increment integer parameter value
     {
       num++;  // same as num = num + 1
     }
     int main(void)
     {
       int n = 0;  // initialize

       printf("%d\n", n);  // print value before function call

       increment(n);   // increment in function (pass-by-value)

       printf("%d\n", n);  // print value after function call

       return 0;
     }
   #+end_src

   #+RESULTS: pass-by-value
   : 0
   : 0

   Increment a number with a pass-by-reference function:
   #+name: pass-by-reference
   #+begin_src C :main no
     void increment(int* num)
     {
       (*num)++;
     }
     int main(void)
     {
       int n = 0;

       printf("%d\n", n);
       increment(&n);
       printf("%d\n", n);

       return 0;
     }
   #+end_src

   #+RESULTS: pass-by-reference
   : 0
   : 1

7. Prove 'algebraically' that *p = i if p = &i - what is *p?
   #+begin_example
    *p = *(&i) = *&(i) = i since *& = 1
   #+end_example
   #+begin_quote
   If p is a pointer to i, then the dereferenced p is the value that
   p points to, i.
   #+end_quote

8. Prove 'algebraically' that **pp = *p if pp = &p - what is **pp?
   #+begin_example
    **pp = **(pp) = **(&p) = *(*& p) = *(p) = *p
   #+end_example
   #+begin_quote
   If pp is a pointer to p, then the double pointer **pp is the value
   that p points to.
   #+end_quote

9. Could you modify [[pass-by-value]] to increment a 1-dim array?
   #+name: pass-by-value array
   #+begin_src C :main no
     void increment2(int num[], int n) // pass array and length of array
     {
       num[0]++;
       num[1]++;
     }
     int main(void)
     {
       int n[2] = {0}; // initialize array

       printf("%d %d\n", n[0], n[1]);
       increment2(n,2);  // arguments: array, length of array
       printf("%d %d\n", n[0], n[1]);

       return 0;
     }
   #+end_src

   #+RESULTS: pass-by-value array
   : 0 0
   : 1 1

10. In the previous example, why are the array values changed in ~main~?
    #+begin_quote
    The array values in ~main~ are changed because arrays are always
    passed by reference: when passed, the array decays into a pointer
    to its first element, which points at the original, not at a
    copy. Consequently, when changing array values in the function,
    they are changed everywhere.
    #+end_quote

* DONE Week 8 - Functions Popquiz & Midterm Assignments
#+attr_html: :width 600px:
[[../img/still_life.jpg]]

/Image: Still Life. Pieter Claesz. 1641./

*THERE IS NO CLASS THIS THURSDAY 10-OCT: INVEST YOUR TIME WISELY!*

*THERE WILL BE OFFICE HOURS 4-4.30 PM and 4.30-5 PM*

** Total grade evolution: Getting better (though not for everyone).

- R code:
  #+begin_src R :file ../img/gradesDensity.png :session *R* :results file graphics output :exports both
    grades1 <- c(0.,7.62,30.16,30.16,32.59,45.24,45.56,53.02,
                 59.26,62.22,63.17,65.4,76.19,98.33,98.41,98.89)
    grades2 <- c(20.56,35.42,42.78,48.75,52.78,57.5,69.86,70.42,
                 75.,76.11,81.53,83.19,86.39,91.25,98.47,104.29)
    grades3 <- c(20.56,31.53,48.41,50.85,52.8,83.78,88.52,89.79,
                 91.32,97.2,100.71,101.01,103.02,105.56,108.99,120.4)

    ## Get the common x and y limits
    xlim <- range(c(grades1, grades2))
    ylim <- range(c(density(grades1)$y, density(grades3)$y))

    ## First plot with specified xlim and ylim
    plot(density(grades1), lwd=2, col="red",
         xlab="", ylab="", main="", xlim=xlim, ylim=ylim, yaxt="n")

    ## Overlay the second plot with the same xlim and ylim
    par(new=TRUE)
    plot(density(grades2), lwd=2, col="blue",
         xlab="", ylab="", main="", xlim=xlim, ylim=ylim, yaxt="n")

    ## Overlay the third plot with the same xlim and ylim
    par(new=TRUE)
    plot(density(grades3), lwd=2, col="darkgreen",
         xlab="Grades [%]", main="Total grades CSC 240",
         xlim=xlim, ylim=ylim, yaxt="n")

    ## Add mean lines for grades1
    abline(v=mean(grades1), col="red", lwd=2)

    ## Add mean lines for grades2
    abline(v=mean(grades2), col="blue", lwd=2)

    ## Add mean lines for grades2
    abline(v=mean(grades3), col="darkgreen", lwd=2)

    ## add a legend
    legend("topleft", legend=c("14-Sep", "30-Sep", "7-Oct"),
           col=c("red", "blue", "darkgreen"), lwd=2)
  #+end_src

  #+RESULTS:
  [[file:../img/gradesDensity.png]]

  - In three weeks, the class average has improved by 25%.
  - This is largely due to generous bonus payouts.
  - The bottom of the class (30%) has not moved much, alas.

** Current assignments (bonus and regular) - get coding!
#+attr_html: :width 600px:
[[../img/bonus.png]]

- You can find a *recording of assignment 6* (function prototypes,
  Oct 7) in the YouTube playlist, and the solution code in GitHub.

- All BONUS assignments and assignment 7 are *due October 14*

- If you're struggling, *come to my office* and we go through the bonus
  assignments together. I'll do (almost) anything to get you coding!

** Popquiz! 12 easy pieces
#+attr_html: :width 600px:
[[../img/popart.jpg]]

The last popquiz 3 weeks ago was probably too difficult. This contains
more problems, but simpler ones. Solving these will also get you very
close to solving the current assignment and bonus assignments.

*Solve as many problems as you can. Put down what you can remember.*

*If you're done early, check your answers [[https://tinyurl.com/function-popquiz][using this file]] with Emacs.*

*I'll use the (confidential) data to give you hints on how to improve.*

*After (at most) 60 minutes, we'll review and a post-mortem*.

*I will make a video on how to tackle these questions (YouTube).*

[[https://github.com/birkenkrahe/alg1/blob/main/org/3_functions_popquiz.org][Problem Org-file]] and [[https://github.com/birkenkrahe/alg1/blob/main/pdf/3_functions_popquiz_solutions.pdf][solution PDF]] are also available online at GitHub.

1. Write function documentation for the following function, which gets
   input from the keyboard, puts it into a one-dimensional array of
   length =m=, and prints each value.
   #+begin_example C
   // Name: input
   // Purpose: Store and print integer array values
   // Returns: Nothing (void)
   // Parameters: Integer array, and integer size of array
   void input(int [], int);
   #+end_example

2. Write a function =sum= that takes an integer array =foo= of length =n=
   sums up its elements, and returns the sum of the elements.
   #+begin_src C :results none
     int sum(int foo[], int n)
     {
       int sum = 0, i;
       for (i = 0; i < n; i++) {
         sum+=foo[i];
       }
       return sum;
     }
   #+end_src

3. Write a function =print= that prints an array =bar= of length =k= using a
   =for= loop.
   #+begin_src C :results none
     void print(float bar[], int k)
     {
       int j;
       for (j = 0; j < k; j++) {
         printf("%g ", bar[j]);
       }
     }
   #+end_src

4. Write a statement that prints a long integer variable =i=, a
   floating-point variable =x= to precision 4, and a Boolean variable =b=.
   #+begin_src C
     #include <stdbool.h>
     int i = 100;
     float x = 3.141592f;
     bool b = true;

     printf("Integer i = %d, float x = %.4f, bool b = %b\n",i,x,b);
   #+end_src

   #+RESULTS:
   : Integer i = 100, float x = 3.1416, bool b = 1

5. Declare a floating-point constant =PI= with the value =3.141592=.
   #+begin_src C :results none
     const float PI = 3.141592;
     float const PI2 = 3.141592;
     #define PI3 3.141592
   #+end_src

6. Comment each line of this code:
   #+begin_src C
     #include <stdio.h>  // include I/O library/header file

     int main(void) // main function, no arguments, returns integer

     { // begin of main program

       int time; // integer variable definition

       printf("Enter time in seconds:\n"); // print a string

       scanf("%d",&time);  // get integer input from stdin

       float answer = (32 * time * time) / 2; // compute result

       printf("\nThe distance is %g feet.\n", answer); // print result

       return 0; // if program completes, return 0

     } // end of main program
   #+end_src

7. Write a nested =for= loop to iterate over a 2 x 2 integer array
   =baz=. Inside the =for= loop, print an array element.
   #+begin_src C
     int baz[2][2]={1,2,3,4};
     for (int i=0;i<2;i++) {
       for (int j=0;j<2;j++) {
         printf("%d ", baz[i][j]);
       }
       puts("");
      }
   #+end_src

   #+RESULTS:
   : 1 2
   : 3 4

8. Change the following function so that the parameter =signal= can be
   passed by reference from the calling function: =morse(&signal)=
   #+begin_src C
     // pass by reference
     void morse ( char  *s )
     {
       printf("Your morse signal was '%c'.\n",  *s );
     }

     int main(void)
     {
       char signal = '-';
       morse(&signal); // pass address-of signal
       return 0;
     }
   #+end_src

   #+RESULTS:
   : Your morse signal was '-'.

9. Write a statement that prints =i=, =p= and =**pp= below, and write after
   the =//= comments what =i=, =p=, and =pp= each are.
   #+begin_src C
     int i  = 100; // integer variable
     int* p = &i; // pointer to the address-of integer variable i
     int** pp = &p; // pointer to the address of the pointer to i
     // print i, p, **pp
     printf("i = %d, p = %p, **pp = %d\n", i, p, **pp);

   #+end_src

   #+RESULTS:
   : i = 100, p = 0x7ffc2d1633a4, **pp = 100

10. For given integers =a= and =b=, complete the selection statement below:
    #+begin_example C
      if (a == b) {
        printf("%d and %d are the same!\n",a,b);
      } else if (a > b) {
        printf("%d is bigger than %d!\n",a,b);
      } else {
        printf("%d is smaller than %d!\n",a,b);
      }
    #+end_example

11. Write a =while= loop that prints your name 10 times before exiting:
    #+begin_src C
      int i = 0;  // start
      while (i < 10) {// stop condition
        printf("Joe ");
        i++;
       }
    #+end_src

    #+RESULTS:
    : Joe Joe Joe Joe Joe Joe Joe Joe Joe Joe

12. You've tangled a source code file as =main.c=. Write the code
    necessary to compile it on the command-line so that the executable
    is called =a.out=
    #+begin_example bash
    gcc main.c # standard output file is `a.out`
    gcc main.c -o a.out  # explicitly create an output file `a.out`
    #+end_example

** Popquiz Post-Mortem
#+attr_html: :width 600px:
[[../img/staalmeesters.jpg]]

*What if you didn't do well on this popquiz?* There are several
possibilities:

1) *You don't do well under pressure.* To remove this obstacle, do the
   quiz all over (without peeking at the solutions): the empty file
   is at [[https://tinyurl.com/function-popquiz][tinyurl.com/functions-popquiz]]

2) *You just don't have the basics* to solve most of the questions. Then
   you must work through the solutions and make sure you understand
   it, and work through the first 15 chapters of w3schools.com for C
   (free and online).

3) You (think you) know the basics, and you understood the review of
   the quiz, but *you're just too darn slow*. Then you need to solve
   more small problems, starting with the bonus problems in the
   course, and you can always ask me for more small problems.

-----
/Image: The Syndics of the Clothmaker's Guild (The Staalmeesters),
Rembrandt van Rijn, 1662/

* DONE Week 9 - VLAs, Compound Literals, Recursion [Oct 14]
#+attr_html: :width 500px:
[[../img/drawing_hands_escher.png]]

- [X] Popquiz results histogram
- [X] Anonymous poll: How much are you coding?
- [X] New grading element: Large projects
- [X] Variable-Length Arrays
- [X] Compound literals
- [ ] The =return=
- [ ] Exit failure or success
- [ ] Recursion: Factorials
- [ ] Quicksort algorithm

** Popquiz results
#+begin_src R :file ../img/pophist.png :session *R* :results file graphics output :exports both
  pop <- c(2.5,0,1,6.5,1.5,4,6,6.5,10,6.5,9.5,10,9,2.5,8,12)
  hist(pop,
       xlab="Points [0-12]",
       ylab="Participants",
       main="Popquiz '12 Easy Pieces' (Oct-8-2024) CSC 240",
       col="lightblue")
#+end_src

#+RESULTS:
[[file:../img/pophist.png]]

- Remember that the 12 pieces unlock many of the bonus assignments.

- Especially valuable: The 10 Entry problem bonus assignment.

- You should be able to code its problems with your eyes closed.

** Anonymous poll: How much have you programmed (in any language) this week?
#+attr_html: :width 600px:
[[../img/poll.png]]

Vote anonymously at strawpoll.com: [[https://strawpoll.com/LVyK2j9oQZ0][strawpoll.com/LVyK2j9oQZ0]]

** "Why coding exercises are KILLING your progress"
#+attr_html: :width 600px:
[[../img/killingExercises.png]]

- *Change of plan:* Large scale projects or why assignments are stupid
  (see Huw Collinbourne's [[https://youtu.be/L0l3LERJDwc?si=6lZj2Er0MvlP3UrY][YouTube video]] shared on the Google chat).

- There will be 6-7 *programming assignments* and perhaps as many bonus
  assignments until the end of term (100 points).

- You can get as many points with a *programming project* of your own
  initiative and design. You must document it as a literate program
  and you must present it (to me), but it doesn't need to be finished.

- Look at a large project as a series of many small exercises, which
  you pose yourself! It's a fight for freedom from the shackles of
  *procrastination*. Graciousness towards yourself is the key.

- Let me know what you want to do and create a shared GDrive to which
  you can invite me, get going and ask me if you need any help.

- I will put this into the gradebook as a bonus category with
  detailed instructions later this week.

- Some example projects:
  1) Build a *text editor* (linked list)
  2) Build a *dictionary* (hash table)
  3) Design a *file system* (dynamic array)
  4) Implement *machine learning* algorithms from scratch.
  5) Implement a *blockchain* (structs)
  6) Build a *melody generator* and music player (strings)
  7) Build a *text adventure game* (strings)

- This could be done in any language that you know (however, ideally I
  know the language), in any case you will be queried.

** Recursion codealong I

- Get the file from [[https://tinyurl.com/recursion-org][tinyurl.com/recursion-org]]

- In Linux:
  #+begin_example sh
  wget -O recursion.org tinyurl.com/recursion-org
  #+end_example

- Open =recursion.org= with Emacs from the terminal:
  #+begin_example sh
  emacs --file recursion.org &
  #+end_example

** Advisees!

- If you are one of my advisees, see me for advising!
- You'll get an email with instructions from me!

** A Treat: Why We Bother Trying to Manipulate Memory
#+attr_html: :width 400px:
[[../img/memory-clip.png]]

- Tune in: [[https://x.com/BenjDicken/status/1846586055048540648][tinyurl.com/memory-clip]] by @BenJDicken on X

#+begin_quote
"This is why memory buffers and caches are so important, especially
for I/O heavy workloads like databases [onlin Non-Volatile Memory]"
#+end_quote

** Review: VLA / Compound Literals / lvalue and rvalue

1. What's a Variable-Length Array (VLA)?
   #+begin_quote
   A VLA is an array whose length is determined at run-time (when the
   program is executed).
   #+end_quote

2. What is a function parameter?
   #+begin_quote
   A function parameter is a dummy value that represents a value to be
   supplied when the function is called.
   #+end_quote

3. What's a VLA parameter?
   #+begin_quote
   A VLA parameter is an function parameter that represents a VLA,
   which is passed when the function is called.
   #+end_quote

4. Which of these declares a VLA?
   #+begin_example C
   int func1(int n, int a[n]);
   int func2(int, int []);
   int func3(int a[n], int n);
   int func4(int a[], int n);
   #+end_example
   #+begin_quote
   - =func1= and =func2= are VLAs
   - =func3= triggers an error because =n= is not known when =int a[n]= is
     declared.
   - =func4= is a regular array parameter
   #+end_quote

5. What's the meaning of 'compound literal', and what's an example?
   #+begin_quote
   A compound literal consists of an array term (like =int []=) and an
   initializer list (like ={1,2,3}=) to save declaring and initializing
   an array.
   #+end_quote

   Example: An on-the-fly lookup table.
   #+begin_src C :main no :tangle getMonthDays.c
     // Function to get the number of days in a month (1-12)
     int get_month_days(int month)
     {
       // Use compound literal for temporary array for days in each month
       return ((int[]){31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31})[month-1];
     }
     // main program
     int main(void)
     {
       int month;
       printf("Enter a month (1-12): ");
       scanf("%d",&month);
       printf("\nMonth %d has %d days.\n", month, get_month_days(month));
       return 0;
     }
   #+end_src

   Test:
   #+begin_src bash :results output
     gcc getMonthDays.c -o main
     echo 10 | ./main
   #+end_src

   #+RESULTS:
   : Enter a month (1-12):
   : Month 10 has 31 days.

6. What's a cast? Give an example and print it.
   #+begin_quote
   The integer =int i = 1;= can be cast (widening) to a =float= with the
   =(float)= operator: =(float)(i)=;
   #+end_quote
   #+begin_src C
     int i = 1;
     printf("Casting integer %d to float %.2f\n",i,(float)(i));
   #+end_src

   #+RESULTS:
   : Casting integer 1 to float 1.00

7. How can you cast & print an integer =int i = 97;= to a character?
   #+begin_src C
     int i = 97;
     printf("Casting integer %d to character %c.\n",i, (char)(i));
   #+end_src

   #+RESULTS:
   : Casting integer 97 to character a.

8. The character pointer =ic= points to the string ="1000"= - How can you
   convert this string to the number =1000=?
   #+begin_src C
     char* ic = "1000";
     printf("%d\n",atoi(ic)); // "ASCII to integer"
   #+end_src

   #+RESULTS:
   : 1000

9. Your program compiles but when you run it you get a "segmentation
   fault", which sounds bad. What could you do?
   #+begin_quote
   Add the compiler option =-Wall= and =-Wextra= - either in the code
   block header or on the command-line:
   #+end_quote
   Command-line example:
   #+begin_src C :tangle flag.c
     int n;
   #+end_src

   #+begin_src bash :results output
     gcc flag.c -Wall -Wextra -o flag # compilation with additional options
     ls -l flag  # listing the executable
     ./flag # executing the executable
   #+end_src

   #+RESULTS:
   : -rwxrwxr-x 1 marcus marcus 15776 Oct 17 09:56 flag

   Code block compilation example:
   #+begin_src C :flags -Wextra :results none

     int n; // define integer
     int a[n]; // define VLA
     scanf("%d",&n); // get integer input
   #+end_src

10. What's an /lvalue/ and what's an /rvalue/? Give an example for each.
    #+begin_quote
    - An /lvalue/ (locator value) represents a memory location. It
      persists in memory and is addressable.
    - An /rvalue/ (right value) represents a transient memory value. It
      does not persist in memory and is not addressable.
    #+end_quote
    For example:
    #+begin_src C
      int x = 10;   // 'x' is an lvalue, '10' is an rvalue
      int* p = &x;  // 'p' is an lvalue, '&x' is an rvalue

      (*p) = 20;      // '*p' is an lvalue, '20' is an rvalue
      x = x + 5;    // 'x' is an lvalue, 'x + 5' is an rvalue
    #+end_src
    Explanation:
    #+begin_quote
    1. ~int x = 10;~
       - =x= is an lvalue because it refers to a location in memory.
       - =10= is an rvalue because it is a literal value assigned to =x=.

    2. ~int *p = &x;~
       - =p= is an lvalue because it represents a memory location.
       - =&x= is an rvalue because it evaluates to the address of the
         variable =x=.

    3. ~(*p) = 20;~
       - =*p= is an lvalue because it refers to the value stored at the
         address pointed to by =p=.
       - =20= is an rvalue because it is a literal value assigned to =*p=.

    4. ~x = x + 5;~
       - =x= is an lvalue because it refers to a memory location.
       - =x + 5= is an rvalue because it results in a computed value (the sum of =x= and 5).
    #+end_quote

* DONE Week 10 - Quicksort & Arrays and Pointers [Oct 21]
#+attr_html: :width 600px:
[[../img/quicksort.png]]

- [X] *Review:* =exit=, =return= and recursion (=power= function)
- [X] New *quiz* (Oct 25) and new *assignment* (Oct 28)
- [X] The *Quicksort* algorithm explained & implemented
- [X] Final *notes* on functions and their use in C
- [ ] *Coding*: Some exercises (incl. [[https://artofproblemsolving.com/wiki/index.php/Euclidean_algorithm][Euclidean algorithm]])

** Review: =return=, =exit=, recursion

1. What is the purpose of a =return= statement in a function? What is
   the shortest example for this that you know?
   #+begin_quote
   To terminate the function and optionally return a value to the
   caller.
   #+end_quote
   Shortest example:
   #+begin_src C :main no :results none
     int main(void) {
       // anything may happen here
       return 0; // returns 0 if successful or 1 otherwise
     }
   #+end_src

2. Can a =void= function use a =return= statement?
   #+begin_quote
   Yes, but without returning a value.
   #+end_quote
   #+begin_src C :main no :tangle main.c
     void hello(char* name, int n) {
       if(n)
         return; // return if n=1
       else
         printf("%s",name); // print if n=0
     }
     int main(void) {
       hello((char*){"Marcus"},1); // initialized as compound literal
       return 0;
     }
   #+end_src

   #+RESULTS:

3. How could you use the =exit= function in C and where is it?
   #+begin_quote
   Both the =exit= function and the macro definitions =EXIT_SUCCESS= (0)
   and =EXIT_FAILURE= (1) are defined in =stdlib.h=.
   #+end_quote
   #+begin_src C
     #include <stdlib.h>
     int status = 0;
     if (status) {
       printf("Exiting with failure...\n");
       exit(EXIT_FAILURE);  // Terminate with failure status
      } else {
       printf("Exiting with success...\n");
       exit(EXIT_SUCCESS);  // Terminate with success status
      }
   #+end_src

   #+RESULTS:
   : Exiting with success...

4. Which examples of recursive functions do you know?
   #+begin_quote
   1. Factorial, based on n! = n * (n-1)!
   2. Power, based on x^n = x * x^(n-1)
   #+end_quote
   Short versions:
   #+begin_src C
     int factorial(int n) {
       return n <= 1 ? 1 : n * factorial(n-1);
     }
     int power(int x, int n) {
       return n == 0 ? 1 : x * power(x,n-1);
     }
     int main(void) {
       int x = 5, n = 3;
       printf("The factorial of n = %d is %d\n", n, factorial(n));
       printf("The %d-th power of %d is %d\n", n, x, power(x,n));
       return 0;
     }
   #+end_src

   #+RESULTS:
   : The factorial of n = 3 is 6
   : The 3-th power of 5 is 125

5. What's the process for a recursive function?
   #+begin_quote
   A recursive function has a winding phase while it calls itself, and
   an unwinding phase after the terminating condition has been met,
   until it has returned to the first function that called itself. No
   relevant value is computed/returned until the winding is complete!
   #+end_quote
   Example:
   #+begin_example
   // Example x^n for x = 5 and n = 3
       call power(5,3) : 3 != 0
         call power(5,2) : 2 != 0
              call power(5,1) : 1 != 0
                   call power(5,0) : 0 == 0 return 1
              return 5 * 1 = 5
         return 5 * 5 = 25
       return 5 * 25 = 125
   #+end_example

* DONE Week 11 - Stack & Pointer Arithmetic [Oct 28]
#+attr_html: :width 600px:
#+caption: Caspar David Friedrich, Mondaufgang am Meer, 1822.
[[../img/mondaufgang_am_meer_CDF_1822.jpeg]]

** Algorithms - Spring'25
#+attr_html: :width 200px:
[[../img/Dive-Into-Algorithms_frontcover.png]] [[../img/zingaro.png]]

Since a number of you are currently looking at CSC 265 'Algorithms':
Dr. Dall'Olio will teach the class with Python, most likely based on
Tuckfield's book "[[https://nostarch.com/Dive-Into-Algorithms][Dive into Algorithms]]" (NoStarch, 2021). This is a
great book and a marvelous choice - lots of fun applications!

That's great news for us because it somewhat relaxes our course:
instead of having to cover a lot more ground, and many more data
structures, we can focus on mastering fundamental data structures like
arrays, linked lists (pointers), stacks (external variables), queues
(=struct=), and trees (=malloc= and recursion).

The other book, "[[https://nostarch.com/algorithmic-thinking-2nd-edition][Algorithmic Thinking]]" by Zingaro (2023) is the one I
was originally going to use for this class - in hindsight it's too
difficult but it would be a great extension reading to this data
structures course: you can get into it right away! I plan to work with
it over the break (or over the summer more likely) myself so that I
don't lose my hard-earned skills.

And that's the thing: If you only put 2 hours into C programming on
your own, and 3 hours of class time, that's 5 hours per week or 75
hours over the term - amounting to almost two full weeks of learning!

Don't throw this away: Keep doing anything that has got even a glimmer
of gold and interest to you. If it's programming small or large games,
solving leetcode or competitive programming problems, or other stuff.

#+begin_quote
"Everyday life is like programming [...] If you love something you can
put beauty into it." -- Don Knuth (Inventor of literate programming)
#+end_quote

** Assignments and Tests (5 weeks from the end of term!)

- [X] New bonus exercise: [[https://lyon.instructure.com/courses/2623/assignments/36047][Recursive Euclidean Algorithm]].

- [X] See also "writing a GCD function" exercise in 4_recursion.org.

- [X] Solution video for assignment 8 (VLA array concatenation):
  [[https://youtu.be/GVA_2AoTdyg][youtu.be/GVA_2AoTdyg]] and PDF version [[https://github.com/birkenkrahe/alg1/blob/main/pdf/concatenateArrays_video.pdf][on GitHub]].

- [X] There will be 2 more assignments and about the same number of
  bonus assignments, and 3 more online tests.

- [X] Remember: You can (but don't have to) write the *final exam*,
  which consists of a selection of 50 questions from all quizzes.

- [X] Remember: You can build your own independent *research project*
  and submit a link to your repo (in GitHub or GDrive) [[https://lyon.instructure.com/courses/2623/assignments/36167][in Canvas]] now.

- [X] *Quicksort*: Will create the promised analysis videos when I find
  the time.

** Modus operandi: 10 suggestions
#+attr_html: :width 600px:
[[../img/mars.png]]

1) *Open* an Org-mode file.
2) *Listen* to my well-prepared ramblings.
3) *Code* along with my small examples.
4) For details, *check* the detailed GitHub lecture.
5) For skills, *solve* exercises and assignments.
6) For mastery, *invent* your own exercises.
7) For assistance, *ask* me and/or ask generative AI.
8) For deep dives, *follow* C and assembly developers on X.com
9) For deep learning, *research* your own large project.
10) For additional support, *form* a coding study group.

** Stacks
#+attr_html: :width 400px:
[[../img/stack2.png]]

- [X] Memory organization
- [X] Storage and scope
- [X] =static= local variables
- [X] Variable scope
- [X] Type conversion
- [X] Type definition with =typedef=
- [X] External variables
- [X] Implementing a stack (LIFO)
- [ ] Guessing a number program -> video

Further study:
- Short (8 min) introduction to stacks (no code) [[https://youtu.be/I37kGX-nZEI?si=PZBYK2KqIh0HzAHu][on YouTube]].
- An even shorter (4 min) introduction to stacks in Python [[https://youtu.be/NKmasqr_Xkw?si=Bt8a_--GDSiVqa7b][on YouTube]].

** Review: Scope and Storage

1. What is the primary purpose of the stack in memory organization?
   #+begin_quote
   The stack is used for storing /local/ variables, especially when
   functions are called. These variables are automatically allocated
   when the function is called, and deallocated when it is left.
   #+end_quote

2. What is the difference between "automatic" and "static" storage
   duration?
   #+begin_quote
   - Variables defined with /block scope/ have automatic storage
     duration. A block is any structure enclosed by { }.
   - Variables defined with file scope have static storage duration,
     e.g. =static= variables in functions, or global aka external
     variables outside of any function.
   #+end_quote

3. Why is the =sizeof= operator crucial for type portability in C?
   #+begin_quote
   - "Type portability" means that the programmer knows the exact
     memory needed, across different computer architectures and
     machines.
   - The =sizeof= operator is evaluated at compile-time (not at
     run-time). It returns the number of bytes required for a
     particular type.
   #+end_quote

4. Which definition is correct:
   #+begin_src C
     static int i = 1;
     int static j = 2;

     printf("%d %d\n", i, j);
   #+end_src

   #+RESULTS:
   : 1 2

   #+begin_quote
   Both definitions are correct. The =static= and the data type keywords
   are interchangeable, just like =const= and data type.
   #+end_quote

   #+begin_src C
     const int k = 3;
     int const l = 4;

     printf("%d %d\n", k, l);
   #+end_src

   #+RESULTS:
   : 3 4

5. Can you define your own data type? How and why would you do it?
   #+begin_quote
   The =typedef= keyword allows you to create an /alias/ for an existing
   data type - this can improve code readability, consistency, and
   portability.
   #+end_quote

6. How about defining a type for a program that computes distance?
   #+begin_src C
     typedef float Distance; // order cannot be changed - `typdef` comes first
     Distance d1 = 10.1;
     Distance d2 = 20.4;

     printf("The total distance was %g\n", d1 + d2);
   #+end_src

   #+RESULTS:
   : The total distance was 30.5

   *Note to self*: order of =typedef= alias keyword??

7. The following example is supposed to display a 10 x 10 arrangement
   of plus signs but it doesn't - can you explain why? Can you fix it?
   #+begin_src C :main no
     int i;  // external counter variable with static storage duration

     void print_one_row(void)
     {
       for (i = 1; i <= 10; i++)
         printf(" +");
     }

     void print_all_rows(void)
     {
       for (i = 1; i <= 10; i++) {
         print_one_row();
         printf("\n");
       }
     }

     int main(void)
     {
       print_all_rows();
       return 0;
     }
   #+end_src

   #+RESULTS:
   : + + + + + + + + + +

   #+begin_quote
   - =print_all_rows= calls =print_one_row=. When the program returns from
     =print_one_row= the first time, =i= has the value 11.
   - Since =i= is an external variable, this value is not deallocated,
     the condition =i < 10= returns =FALSE=, the =for= loop is left and no
     further row is printed.
   #+end_quote

** Pointer Arithmetic
#+attr_html: :width 300px:
#+caption: https://xkcd.com/138
[[../img/pointers.png]]

- [X] [[https://github.com/birkenkrahe/alg1/blob/main/img/ch12_1.png][Pointers can point to array elements]]
- [X] [[https://github.com/birkenkrahe/alg1/blob/main/img/ch12_3.png][Adding and subtracting pointers]]
- [ ] Comparing pointers
- [ ] Pointers to compound literals
- [ ] Using pointers to process arrays
- [ ] Combining indirection and compound operators
- [ ] Using an array name as a pointer
- [ ] Revisiting =reverse.c=

See also: Excellent [[https://youtu.be/MIL2BK02X8A?si=BlJZAsFF3OmnKLeD][freeCodeCamp video course just on pointers]] (2 hrs)

To code along, download and open in Emacs:
[[https://tinyurl.com/pointers-codealong][tinyurl.com/pointers-codealong]]

#+begin_example bash
  wget -O pointers.org tinyurl.com/pointers-codealong
  emacs --file pointers.org
#+end_example

* DONE Week 12 - Pointer arithmetic II [Nov 4]
#+attr_html: :width 600px:
[[../img/choose_the_worthy_1936.jpg]]

/Image: Soviet election poster "Choose the worthy!" (1936)/

---- *REMEMBER: THERE IS NO CLASS MEETING THIS THURSDAY NOVEMBER 7* ----

- [X] Programming assignment 9 (Nov 11) and bonus assignment (Dec 6)
- [X] Review: Pointer arithmetic I (see quiz)
- [ ] Continued: Pointer arithmetic II
- [ ] Strings (video lecture - review & quiz next week)

** Review: Pointer arithmetic I

1. What does "pointer arithmetic" mean?
   #+begin_quote
   It refers to using pointers to access array elements that they're
   pointing at. You can add an integer to a pointer, subtract an
   integer from a pointer, subtract pointers from one another, and
   compare pointers. All of these operations are translated to array
   index operations.
   #+end_quote

2. What is the meaning of the =*= symbol (asterisk) in connection with pointers?
   #+begin_quote
   1. In a pointer /declaration/ (=int *p = &a[0];=) it is a symbol to
      declare a pointer structure with the given data type (=int=).
   2. In a pointer statement (=*p = 5;=) it is an /indirection/ operator
      that dereferences the pointer =p= to access the value stored at
      the address =p= points at: =*p = *(&i) = i=.
   #+end_quote

3. Give an example for adding an integer to a pointer.
   #+begin_src C
     int a[10]={100,101,102,103,104,105,106,800,900,1000}, *p, i;
     p = &a[0]; // p points to a[0] = 100
     i = 4;
     printf("*p = %d, a[%d] = %d\n",*(p+i), i, a[i]);
     printf("p = %p, &a[%d] = %p\n",(p+i), i, &a[i]);
   #+end_src

   #+RESULTS:
   : *p = 104, a[4] = 104
   : p = 0x7fff3d5f4d60, &a[4] = 0x7fff3d5f4d60

4. Give an example for subtracting an integer from a pointer.
   #+begin_src C
     int a[10]={100,101,102,103,104,105,106,800,900,1000}, *p, i;
     p = &a[9]; // p points at a[9] = 9
     i = 3;
     printf("*p = %d, a[%d] = %d\n",*(p-i), 9-i, a[9-i]);
     printf("p = %p, &a[%d] = %p\n", (p-i), 9-i, &a[9-i]);
   #+end_src

   #+RESULTS:
   : *p = 106, a[6] = 106
   : p = 0x7ffe01f7c318, &a[6] = 0x7ffe01f7c318

5. Give an example for subtracting one pointer from another.
   #+begin_src C
     int a[10]={100,101,102,103,104,105,106,800,900,1000}, *p, *q;
     p = &a[9]; // p points at a[9]
     q = &a[3];
     printf("p - q = %ld\n", p-q); // distance between locations as indices
     printf("*p - *q = %d\n", *p-*q); // difference of values
     printf("&a[9] - &a[3] = %ld\n", &a[9] - &a[3]); // distance between addresses
   #+end_src

   #+RESULTS:
   : p - q = 6
   : *p - *q = 897
   : &a[9] - &a[3] = 6

6. If =p = &a[3]=, what is =p+=3= ?
   #+begin_quote
   If =p= points at the array element =a[3]=, then =p+=3= (or =p = p + 3=)
   points at the array element =a[3+3] = a[6]=.
   #+end_quote

** Strings (online to code along with - starting Nov 4)

Planned: 10-part series of (15') video with code along examples.

1. [ ] String literals
2. [ ] String variables
3. [ ] Reading and writing strings
4. [ ] Accessing the characters in a string
5. [ ] Using the C string library
6. [ ] Program: Printing a One-Month Reminder List
7. [ ] String idioms
8. [ ] Arrays of Strings
9. [ ] Program: Checking planet names
10. [ ] Review questions

** Pointer arithmetic II

To code along, download and open in Emacs:
[[https://tinyurl.com/pointers-codealong-2][tinyurl.com/pointers-codealong-2]] (pre-filled from last time)

- [ ] Comparing pointers
- [ ] Pointers to compound literals
- [ ] Using pointers to process arrays
- [ ] Combining indirection and compound operators
- [ ] Using an array name as a pointer
- [ ] Revisiting =reverse.c=

* DONE Week 13 - Strings [Nov 11]
#+attr_html: :width 400px:
[[../img/string_theory.png]]

- [X] First video lecture on strings is live (quiz 9)
- [X] Quiz 8 - Stack, scope and pointer arithmetic *due tonight*
- [X] Quiz 9 - available until next week (watch the video)
- [ ] Lecture + codealong: Strings
- [ ] Structures (=struct=, =enum=, =union=)

** IN PROGRESS Strings

There will be quiz questions. [[https://www.youtube.com/watch?v=aE5k6UyhYaA&list=PLwgb17bzeNygqkMODQYfL1BEWHzft3gsJ&pp=gAQBiAQB][See playlist on YouTube]].

Lectures with short coding exercises (handout to be printed):

1) [X] String literals (aka string constants) - *video 23 min*
2) [X] String variables
3) [X] Reading and writing strings
4) [ ] Writing functions that process strings
5) [ ] Understanding string-handling functions in the C library
6) [ ] Sample program: List of daily reminders (video?)
7) [ ] Searching, copying, strings
8) [ ] Arrays of strings
9) [ ] Command-line arguments (class)
10) [ ] Sample program: Checking planet names (video?)

There will be a quiz (10), a mandatory and a bonus program assignment.

To code along (with exercises): [[https://tinyurl.com/strings-org][tinyurl.com/strings-org]]

** Review: String literals, variables, reading and writing strings

1. *What is a string literal?*
   #+begin_quote
   A string literal is a sequence of characters enclosed within double
   quotes.
   #+end_quote

   #+begin_src C
     printf("Hello, world!"); // string literal: "Hello, world!"
   #+end_src

   #+RESULTS:
   : Hello, world!

2. *How can two lines of text be joined together?*
   #+begin_quote
   When the compiler finds white space between string literals, it
   will join them.
   #+end_quote

   #+begin_src C
     printf("\"To be or not to be, "
            "that is the question.\""
            "\n-William Shakespeare, Hamlet");
   #+end_src

   #+RESULTS:
   : "To be or not to be, that is the question."
   : -William Shakespeare, Hamlet

3. *What's the difference between these statements? What's the output?*
   #+name: helloWorld
   #+begin_src C
     // A
     char *ptr = "Hello, world!";
     // B
     char word = "Hello, world!"[0];
   #+end_src

   Output
   #+begin_src C :noweb yes
     <<helloWorld>>

     printf("%c ", *ptr);
     printf("%c", word);
   #+end_src

   #+RESULTS:
   : H H

   #+begin_quote
   Explanation: =ptr= points at the first letter of the string literal,
   and =word= extracts the first element of the string literal. The
   dereferenced pointer and the character variable print the same.
   #+end_quote

4. *Can you modify a string literal - like "Hello, world!"?*
   #+begin_quote
   No, because being /literal/ means that it's constant.
   #+end_quote

   #+begin_src C :results none
     char *p = "Hello, world!"; // p points to `H`
     ,*p = 'h';
   #+end_src

5. *How can I change "Hello, world!" to "hello, world!"?*
   #+begin_quote
   By storing it in a string /variable/ and overwriting the first
   element.
   #+end_quote

   #+begin_src C
     char *p = "Hello, world!"; // cannot be modified - string literal

     char s[] = "Hello, world!"; // string variables are arrays

     s[0] = 'h';

     printf("%s\n", s);
   #+end_src

   #+RESULTS:
   : hello, world!

6. *How many characters do I need to reserve to store a string of length N?*
   #+begin_quote
   A string of length N must be stored in a =char= array of length N+1.
   #+end_quote

7. *What happens if you underfill a string?*
   #+begin_quote
   If you don't fill a declared character array, the unused places are
   filled with null characters =\0=.
   #+end_quote

   #+begin_src C
     char msg[10] = "Welcome"; // 9 characters + null value = 10

     for (int i=0; i<12; i++)
       if (i < 7)
         printf("msg[%d] = %c\n", i, msg[i]);
       else
         printf("msg[%d] = %d\n", i, msg[i]);
   #+end_src

   #+RESULTS:
   #+begin_example
   msg[0] = W
   msg[1] = e
   msg[2] = l
   msg[3] = c
   msg[4] = o
   msg[5] = m
   msg[6] = e
   msg[7] = 0
   msg[8] = 0
   msg[9] = 0
   msg[10] = 0
   msg[11] = 97
   #+end_example

8. *How can you print the first 5 letters of "Hello, world!"
   left-aligned on 10 spaces?*

   #+begin_src C
     char str[]="Hello, world!";
     puts("|----|----|----|");
     printf("%-10.5s\n",str);
   #+end_src

   #+RESULTS:
   : |----|----|----|
   : Hello

9. *What's the fastest way to store a line of text from the keyboard?*

   #+begin_src bash :results output :exports both
     echo \"Three things are important: To be kind, to be kind, and to be kind.\"\
          > strinput
     cat strinput
   #+end_src

   #+RESULTS:
   : "Three things are important: To be kind, to be kind, and to be kind."

   #+begin_src C :cmdline < strinput
     char str[80];
     gets(str);
     printf("%s",str);
   #+end_src

   #+RESULTS:
   : "Three things are important: To be kind, to be kind, and to be kind."

10. *What's the safe way to get a name as keyboard input?*

    #+begin_src bash :results output
      echo "Marcus Birkenkrahe" > strinput # write to file
      cat strinput # view file
    #+end_src

    #+RESULTS:
    : Marcus Birkenkrahe

    #+begin_src C :cmdline < strinput
      char str[80]; // declare string

      fgets(str, sizeof(str), stdin); // get keyboard input (`stdin`)

      printf("%s\n", str); // print input to screen (`stdout`)
    #+end_src

    #+RESULTS:
    : Marcus Birkenkrahe
    :

    #+begin_quote
    Note: A newline character =\n= is included at the end of =fgets=
    because the user has pressed =RET= to send the input to =stdin=.
    #+end_quote

-----
Now, download the string codealong file again (there are a few new
exercises): [[https://tinyurl.com/strings-org][tinyurl.com/strings-org]]

* DONE Week 14 - Structures [Nov 18]
#+attr_html: :width 500px:
[[../img/gettysburg2.jpg]]

#+begin_quote
Nov 19, 1863: Lincoln's Gettysburg address: »This nation, under God,
shall have a new birth of freedom—and that government of the people,
by the people, for the people, shall not perish from the earth.«
#+end_quote

- [X] Last quiz (10) and assignments on strings (with bonus) available
- [X] Exit quiz on current topics as bonus in last week of term
- [X] Lecture: Command-line arguments =main(int argc, char *argv[])=
- [X] Lecture: =struct= data structures & other user-defined structures
- [ ] Bonus programs: using =main(int argc char **argv)=, =struct=, =malloc=
- [ ] Lecture: Dynamic memory allocation (=malloc=)
- [ ] Tips for Thanksgiving Break

** Review: Strings II (see also quiz 10)

1. What is the safe way for reading strings from the keyboard?
   #+begin_quote
   Answer: =fgets(str, sizeof(str), stdin);=.
   #+end_quote

2. What happens if you try to modify a string literal in C?
   #+begin_quote
   Answer: It leads to undefined behavior.
   #+end_quote

3. How does =fgets()= handle the newline character at the end of input?
   #+begin_quote
   Answer: It includes the newline character in the string.
   #+end_quote

4. Where does =ptr= point at in: =char *ptr = "Hello, world!";=?
   #+begin_quote
   Answer: The pointer points to a read-only memory location.
   #+end_quote

5. What is the purpose of using =const= in the parameter =const char *s=
   of a function?
   #+begin_quote
   Answer: To prevent modifications to the string but not the pointer itself.
   #+end_quote

6. How can you iterate over a string =str= with pointer arithmetic?
   #+begin_quote
   Answer: `for (; *str != '\0'; str++)`
   #+end_quote

7. What happens when you pass a string literal directly to a function
   declared as: =int f(char *s)=, as in =f("hello")=
   #+begin_quote
   Answer: The function receives a pointer to the string literal's
   first element, ="hello"[0] = 'h'=
   #+end_quote

8. What is the key difference between calling a string function =void
   f(char *s)= with a pointer variable and with a string literal?
   #+begin_quote
   Answer: Pointer variables point to modifiable memory, while string
   literals (which are constant) point to read-only memory.
   #+end_quote

9. What is the main difference between modifying a pointer to a string
   and modifying the string itself e.g. with array subscripting?
   #+begin_quote
   Answer: Modifying a pointer changes where it points, while
   modifying the string itself (via array subscripting) changes the
   data stored in memory if the string is in a modifiable location
   (e.g., a character array).
   #+end_quote

   #+begin_src C
     char *p = "Hello";
     p = "World"; // This is fine; `p` now points to "World".
     printf("%s",p);
   #+end_src

   #+RESULTS:
   : World

10. Why do we not have to dereference =p= in the previous code?
    #+begin_quote
    Answer: because the =%s= format specifier in =printf= expects a pointer
    to the first character of the string.
    #+end_quote

11. What if we want to print the first character of "World" only? 
    #+begin_src C
     char *p = "Hello";
     p = "World";
     printf("%c",*p); // *p dereferences p[0] = 'W'
   #+end_src

   #+RESULTS:
   : W

12. What do we get if we use =printf("%d",*p);= instead?
    #+begin_src C
     char *p = "Hello";
     p = "World";
     printf("%d",*p); // *p dereferences p[0] = 'W' = 87 as ASCII
   #+end_src

   #+RESULTS:
   : 87

13. Why is modifying a string literal considered unsafe in C?
    #+begin_quote
    Answer: String literals are stored in read-only memory, and
    modifying them leads to undefined behavior.
    #+end_quote

** Command-line arguments - passing stuff to a C program

[Re-] open your string code along file.

** =struct= data structures

- Download this file to code along & practice:
  
  [[https://tinyurl.com/structures-org][tinyurl.com/structures-org]] (Tuesday)
 
  [[https://tinyurl.com/structures2-org][tinyurl.com/structures2-org]] (Thursday)

- We're heading towards "linked lists", which requires the following
  concepts:
  1) [X] Pointers
  2) [X] Structures
  3) [ ] Dynamic memory management with =malloc= (C) or =new= (C++), =free=
     (C) or =delete= (C++)

- We'll discuss:
  1. [X] Declaring and using structures (=struct=)
  2. [X] Initializing and operating on structures
  3. [ ] Structure types: Tags and type definition
  4. [ ] Structures as arguments and return values
  5. [ ] Nested structures and arrays of structures

- Extended structure examples - a parts database (video)

- Bonus assignment on structures (for you to practice)

** Review: C structures

1. What are =argc= and =argv= in the =main= function, and how are they used
   in C programs?
   #+BEGIN_QUOTE
   =argc= is the "argument count," representing the number of
   command-line arguments, including the program name. =argv= is the
   "argument vector," an array of pointers to strings representing
   the command-line arguments.
   #+END_QUOTE

2. Why would you use =main(int argc, char **argv)= instead of
   =main(void)= in a C program?
   #+BEGIN_QUOTE
   Using =main(int argc, char *argv[])= or =main(int argc, **argv)=
   allows the program to access command-line arguments, enabling
   customization of program behavior based on user input.
   #+END_QUOTE

3. What is a =struct= in C, and why is it used?
   #+BEGIN_QUOTE
   A =struct= in C is a user-defined data type that groups related
   variables of different types under one name. It is used to
   represent complex objects like points, employees, or students.
   #+END_QUOTE

4. How are =struct= members accessed in C?
   #+BEGIN_QUOTE
   Using the dot operator (=.=) (aka selector), for example, =p1.x= to
   access the =x= member of a =struct Point p1=.
   #+END_QUOTE

5. How is a =struct= different from an array in C?
   #+BEGIN_QUOTE
   A =struct= can store elements of different types with named members,
   while an array stores multiple elements of the same type and uses
   indices to access them. They are similar in that both use contingent
   memory.
   #+END_QUOTE

6. Why is the =strcpy= function necessary when working with =struct=
   members that are strings?
   #+BEGIN_QUOTE
   The =strcpy= function is necessary to copy a string into a =struct=
   member because direct assignment of strings to character arrays is
   not allowed in C.
   #+END_QUOTE

7. How can you initialize a =struct= in C? Provide an example.
   #+BEGIN_QUOTE
   A =struct= can be initialized using curly braces with values for its
   members in order, for example: =struct Point p1 = {10, 20};=.
   #+END_QUOTE

8. What is the advantage of using =struct= over separate variables in C?
   #+BEGIN_QUOTE
   A =struct= groups related variables of different types under one
   name, making the code more organized and easier to manage.
   #+END_QUOTE

9. How does the memory layout of a =struct= affect its members?
   #+BEGIN_QUOTE
   =struct= members are stored in memory in the order they are declared,
   with each member occupying its own memory space.
   #+END_QUOTE

10. What happens if two =struct= definitions with the same name are
    declared in different code blocks in C?
    #+BEGIN_QUOTE
    There will be no conflict because =struct= names have block scope and
    are local to the block in which they are defined.
    #+END_QUOTE

11. How would you declare and use a =struct= to represent an employee
    with fields for =name=, =number=, and =salary= in C?
    #+BEGIN_SRC C
      // declaration of a tagged structure
      struct Employee {
        char name[30];
        int number;
        float salary;
      };
      // using structure in the main program
      struct Employee emp1;
      strcpy(emp1.name, "John Doe");
      emp1.number = 1234;
      emp1.salary = 50000.0;
    #+END_SRC

** TODO Tips for Thanksgiving break
#+attr_html: :width 400px: 
[[../img/you_got_this.png]]

- [ ] If you need a better grade: Sit for the final exam 

- [ ] To ace the final exam: Drill yourself with all quizzes

- [ ] You can attempt any quiz any number of times

- [ ] Complete some bonus assignments to make up for lost points

- [ ] If you're bored, ask me for more exercises or check out David
  Zingaro's "Algorithmic Thinking" (NoStarch, 2023), with worked up
  examples from programming competitions.
  
  
* Week 16 - Dynamically allocated memory & Linked lists [Dec 2]
#+attr_html: :width 400px: 
[[../img/girl_reading_on_a_sofa.jpg]]

/[[https://live.staticflickr.com/65535/51267388266_19a4d2c74a_b.jpg][Image:]] Girl reading on sofa, Israel Isaacs (1920)/.

- [X] Bonus programs: using =main(int argc char **argv)=, =struct=, =malloc=
- [ ] Code along lecture: Dynamic memory allocation (=malloc= and =free=)
- [ ] Code along lecture: Linked lists

** TODO Dynamic memory allocation

Code along file (Org-mode): [[https://tinyurl.com/malloc-org][tinyurl.com/malloc-org]]

** TODO Linked lists

Code along file: ---

* Week 17 - Final exam (optional) [Dec 10]

According to the [[https://assets.speakcdn.com/assets/2433/fa24_final_exam_schedule.pdf][published exam schedule]], the final exam will take
place on Tuesday, December 10, at 8-10 am in room 104 Lyon building.
